////////////////////////////////////////////////////////////////////////
//
// SchemaTypes.h
//
// This file was generated by XMLSpy 2005 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#ifndef ALTOVA_SCHEMATYPES_H_INCLUDED
#define ALTOVA_SCHEMATYPES_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

#ifdef WIN32
#include <tchar.h>
#endif

namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  CSchemaType
//
////////////////////////////////////////////////////////////////////////

class  CSchemaTypeNumber;
class  CSchemaTypeCalendar;

class ALTOVA_DECLSPECIFIER CSchemaType : public CBaseObject
{
public:
	typedef enum {
		// numeric types
		k_bool,
		k_byte, 
		k_unsigned_byte,
		k_short,
		k_unsigned_short,
		k_int,
		k_unsigned_int,
		k_long,
		k_unsigned_long,
		k_float,
		k_double,
		k_decimal,
		// calendar types
		k_Duration,
		k_Time,
		k_Day,
		k_Month,
		k_MonthDay,
		k_Year,
		k_YearMonth,
		k_Date,
		k_DateTime,
		// else
		k_String,
		k_Base64Binary,
		k_HexBinary,
		// ----------
		k_count,
		k_unknown = -1
	} ETypes ;

	// Construction
	CSchemaType();

	enum { TYPE = k_unknown };

	enum {
		WHITESPACE_PRESERVE,
		WHITESPACE_REPLACE,
		WHITESPACE_COLLAPSE
	};

	// Accessors
	bool											IsNull() const						{ return m_bIsNull; }
	void											SetIsNull( bool bIsNull )			{ m_bIsNull = bIsNull; if( bIsNull ) m_bIsEmpty = true; }
	bool											IsEmpty() const						{ return m_bIsNull || m_bIsEmpty; }
	void											SetIsEmpty( bool bIsEmpty )			{ m_bIsEmpty = bIsEmpty; if( !bIsEmpty ) m_bIsNull = false; }

	// --------- Interface ----------
	// Operators
	virtual bool									ToBool() const						{ return !IsEmpty(); }	// like XPATH function boolean()
	virtual operator								tstring() const = 0;




	// Operations
	virtual void									Empty()								{ m_bIsNull = false; m_bIsEmpty = true; }
	virtual bool									Parse( const TCHAR* szValue );
	virtual CSchemaType&							Assign( const CSchemaType& rOther );

	virtual CSchemaTypeNumber*						GetSchemaTypeNumberPtr() const		{ return NULL; }
	virtual CSchemaTypeCalendar*					GetSchemaTypeCalendarPtr() const	{ return NULL; }

	// statics
	static const TCHAR*								SchemaType2String( ETypes eType );

	static bool										CompareEqual( const CSchemaType& rObj1, const CSchemaType& rObj2);
	static bool										CompareLess( const CSchemaType& rObj1, const CSchemaType& rObj2);

	static bool										CompareNotEqual( const CSchemaType& rObj1, const CSchemaType& rObj2 )	{ return !CompareEqual(rObj1, rObj2); }
	static bool										CompareGreater( const CSchemaType& rObj1, const CSchemaType& rObj2 )	{ return CompareLess(rObj2, rObj1); }
	static bool										CompareLessEqual( const CSchemaType& rObj1, const CSchemaType& rObj2 )	{ return CompareLess(rObj1, rObj2) || CompareEqual(rObj1, rObj2); }
	static bool										CompareGreaterEqual( const CSchemaType& rObj1, const CSchemaType& rObj2 )	{ return CompareLess(rObj2, rObj1) || CompareEqual(rObj1, rObj2); }
protected:


private:
	bool											m_bIsEmpty;	// indicates if text-content of element is empty
	bool											m_bIsNull;	// indicates if the element is existing
};

inline tostream& operator<<(tostream& os, CSchemaType& t)
{
	return os << ((tstring)t).c_str();
}

} // namespace altova



#endif // ALTOVA_SCHEMATYPES_H_INCLUDED
