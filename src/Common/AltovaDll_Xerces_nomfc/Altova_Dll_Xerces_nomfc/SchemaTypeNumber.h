////////////////////////////////////////////////////////////////////////
//
// SchemaTypeNumber.h
//
// This file was generated by XMLSpy 2005 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#ifndef ALTOVA_SCHEMATYPENUMBER_H_INCLUDED
#define ALTOVA_SCHEMATYPENUMBER_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

#include "SchemaTypes.h"
#include <math.h>


namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  Utility functions and templates
//
////////////////////////////////////////////////////////////////////////


namespace ICMapforceMachineUtil
{

template<typename TValue>
TValue InRangeInt(TValue nValue, __int64 nMin, __int64 nMax)
{
	if( nValue < nMin || nValue > nMax )
		ThrowOutOfRangeError()
	return nValue;
}


template<typename TValue>
TValue InRangeDbl(TValue nValue, const double nPosMin, const double nPosMax)
{
	TValue nTmpValue = nValue;
	if( nTmpValue == 0 )
		return nValue;
	if( nTmpValue < 0 )
		nTmpValue = -nTmpValue;
	if( nTmpValue >= nPosMin  &&  nTmpValue <= nPosMax )
		return nValue;
	ThrowOutOfRangeError();
}

} // end of namesapce ICMapforceMachineUtil


////////////////////////////////////////////////////////////////////////
//
//  CSchemaTypeNumber
//
////////////////////////////////////////////////////////////////////////

class ALTOVA_DECLSPECIFIER CSchemaTypeNumber
{
public:
	CSchemaTypeNumber() {};

	// architecture used is min. 32-bit so all smaller datatypes are omitted for calculation purposes
	// Note: unsigned datatypes have to be casted explicitly
	virtual long		ToLong() const = 0;		// 32 Bit integer
	virtual __int64		ToInt64() const = 0;	// 64 Bit integer
	virtual float		ToFloat() const = 0;	// 32 Bit floating-point
	virtual double		ToDouble() const = 0;	// 64 Bit floating-point

	virtual CSchemaType::ETypes NumericType() const = 0;
	static TCHAR* GetFormatString( CSchemaType::ETypes eType )
	{
		switch( eType )
		{
		case CSchemaType::k_byte:				return	_T("%hi");
		case CSchemaType::k_unsigned_byte:		return	_T("%hu");
		case CSchemaType::k_short:				return	_T("%hi");
		case CSchemaType::k_unsigned_short:		return	_T("%hu");
		case CSchemaType::k_int:				return	_T("%li");
		case CSchemaType::k_unsigned_int:		return	_T("%lu");
#ifdef _WINDOWS
		case CSchemaType::k_long:				return	_T("%I64i");
		case CSchemaType::k_unsigned_long:		return	_T("%I64u");
#else	//! Unix/Linux下不支持%I64格式串,等价字符串为%ll	
		case CSchemaType::k_long:				return	_T("%lld");
		case CSchemaType::k_unsigned_long:		return	_T("%llu");
#endif
		case CSchemaType::k_float:				return	_T("%G");
		case CSchemaType::k_double:				return	_T("%lG");
		case CSchemaType::k_decimal:			return	_T("%lf");
		}
		return _T("");
	}

	static void TruncTrailingZeros( TCHAR* pszString, int nMinPrecision = 0 )
	{
		if( pszString == NULL )
			return ;

		TCHAR* pszComma = _tcschr( pszString, _T('.') );
		if( pszComma == NULL )
			return ;

		TCHAR* pszPos = 0;
		for( pszPos = pszString + _tcslen( pszString ) - 1; 
				pszPos > ( pszComma + nMinPrecision )  &&  *pszPos == _T('0'); 
				pszPos-- ) 
		{
			*pszPos = 0;
		}

		if( nMinPrecision == 0  &&  pszPos == pszComma )
			*pszPos = 0;
	}

};


//	calctype and ToCalcType() below are used for numerical operations with
//  CSchema... types (containing a value possible to be represented as number)
//  All numerical calculation functions access the value via ToCalcType().
//	Calculation-type is minimum 32 Bit (because we've 32 Bit processors) and
//	must be always signed (for unsigned use the next bigger type).

////////////////////////////////////////////////////////////////////////
//
//  template CSchemaNumber<..>
//
////////////////////////////////////////////////////////////////////////


template <typename TValue, typename TCalcValue, CSchemaType::ETypes eNumericType > 
class CSchemaNumber : public CSchemaTypeNumber, public CSchemaType
{
public:
	// Construction
	CSchemaNumber() : m_Value(0) {};
	CSchemaNumber( const TValue value ) : m_Value( value )								{ SetIsEmpty( false ); }
	CSchemaNumber( const TCHAR* szValue ) : m_Value( 0 )								{ Parse( szValue ); }
	CSchemaNumber( const CSchemaType& rOther )											{ Assign( rOther ); }


	// Operators
	virtual operator									TValue() const					{ return IsEmpty() ? (TValue)0	: m_Value; }
	virtual CSchemaNumber& operator	= (const TValue nValue)							
	{ 
		SetIsEmpty( false ); 
		m_Value = nValue; 
		return *this; 
	}

	virtual CSchemaNumber& operator	= (const CSchemaType& rOther)						{ return (CSchemaNumber&)Assign( rOther ); }

	TCalcValue											ToCalcValue() const				{ return ( TCalcValue )m_Value; }

	// ---------- Interface CSchemaType ----------
	// Operators
	virtual bool										ToBool() const			
	{ 
		if( !CSchemaType::ToBool() )
			return (bool)0;
		return m_Value != 0; 
	}

	virtual operator									tstring() const		
	{ 
		if( IsEmpty() )
			return _T("");
		TCHAR szValue[65];
		_sntprintf(szValue, 65, GetFormatString(eNumericType), m_Value);
		return szValue;
	}


	// Operations
	virtual void										Empty() 
	{ 
		CSchemaType::Empty();
		m_Value = 0;
	}

	virtual bool										Parse( const TCHAR* szValue )
	{
		if( !CSchemaType::Parse( szValue ) )
			return false;
		InternalNumParse( szValue );
		return !IsEmpty();
	}

	virtual CSchemaType&								Assign( const CSchemaType& rOther )
	{
		if( CSchemaType::Assign( rOther ).IsEmpty() )
			return *this;

		const CSchemaTypeNumber* pNumberType = dynamic_cast<const CSchemaTypeNumber*>(&rOther);
		if( pNumberType == NULL )
			throw CAltovaException( CAltovaException::eError1, _T("") );
		switch( TYPE )
		{
		case CSchemaType::k_float:			m_Value = (TValue)pNumberType->ToFloat();	break;
		case CSchemaType::k_double:
		case CSchemaType::k_decimal:		m_Value = (TValue)pNumberType->ToDouble();	break;
		case CSchemaType::k_long:
		case CSchemaType::k_unsigned_long:	m_Value = (TValue)pNumberType->ToInt64();	break;
		default:
			m_Value = (TValue)pNumberType->ToLong();
		}

		return *this;
	}

	virtual CSchemaTypeNumber*							GetSchemaTypeNumberPtr() const				{ return (CSchemaTypeNumber*)this; }

	// ---------- Interface CSchemaTypeNumber ----------
	virtual ETypes										NumericType() const							{ return (CSchemaType::ETypes)TYPE; }
	virtual long										ToLong() const								{ return IsEmpty() ? (long)0	: ICMapforceMachineUtil::InRangeInt<long>((long)m_Value, LONG_MIN, LONG_MAX); }
	virtual __int64 									ToInt64() const								{ return IsEmpty() ? (__int64)0	: ICMapforceMachineUtil::InRangeInt<__int64>((__int64)m_Value, _I64_MIN, _I64_MAX); }
	virtual float										ToFloat() const								{ return IsEmpty() ? (float)0	: ICMapforceMachineUtil::InRangeDbl<float>((float)m_Value, 3.4E-38, 3.4E+38); }
	virtual double										ToDouble() const							{ return IsEmpty() ? (double)0	: ICMapforceMachineUtil::InRangeDbl<double>((double)m_Value, 1.7E-308, 1.7E+308); }

	enum { TYPE = eNumericType };
	typedef TValue										basetype;
	typedef TCalcValue									calctype;

protected:
	void												InternalNumParse( const TCHAR* szValue )	{ m_Value = _ttoi(szValue); }

	TValue												m_Value;
};


////////////////////////////////////////////////////////////////////////
//
//  CSchemaByte
//	CSchemaUnsignedByte
//	CSchemaShort
//	CSchemaUnsignedShort
//	CSchemaInt
//	CSchemaUnsignedInt
//	CSchemaLong
//	CSchemaUnsignedLong
//	CSchemaFloat
//	CSchemaDouble
//	CSchemaDecimal
//
//	CSchemaInteger
//	CSchemaNegativeInteger
//	CSchemaPositiveInteger
//	CSchemaNonPositiveInteger
//
////////////////////////////////////////////////////////////////////////


typedef CSchemaNumber<char,				long,		CSchemaType::k_byte				>	CSchemaByte;
typedef CSchemaNumber<unsigned char,	long,		CSchemaType::k_unsigned_byte	>		CSchemaUnsignedByte;
typedef CSchemaNumber<short,			long,		CSchemaType::k_short			>	CSchemaShort;
typedef CSchemaNumber<unsigned short,	long,		CSchemaType::k_unsigned_short	>		CSchemaUnsignedShort;
typedef CSchemaNumber<long,				long,		CSchemaType::k_int				>		CSchemaInt;	
typedef CSchemaNumber<unsigned long,	__int64,	CSchemaType::k_unsigned_int		>		CSchemaUnsignedInt;
typedef CSchemaNumber<__int64,			__int64,	CSchemaType::k_long				>		CSchemaLong;
typedef CSchemaNumber<unsigned __int64,	__int64,	CSchemaType::k_unsigned_long	>		CSchemaUnsignedLong;
typedef CSchemaNumber<float,			float,		CSchemaType::k_float			>	CSchemaFloat;
typedef CSchemaNumber<double,			double,		CSchemaType::k_double			>	CSchemaDouble;
typedef CSchemaNumber<double,			double,		CSchemaType::k_decimal			>	CSchemaDecimal;

typedef CSchemaLong		CSchemaInteger;
typedef CSchemaInteger	CSchemaNegativeInteger;
typedef CSchemaInteger	CSchemaNonNegativeInteger;
typedef CSchemaInteger	CSchemaPositiveInteger;
typedef CSchemaInteger	CSchemaNonPositiveInteger;


template<> 
inline float CSchemaUnsignedLong::ToFloat() const
{
	return IsEmpty() ? (float)0.0	: ICMapforceMachineUtil::InRangeDbl<float>((float)ICMapforceMachineUtil::InRangeInt<__int64>(m_Value, _I64_MIN, _I64_MAX), 3.4E-38, 3.4E+38); 
}

template<>
inline double CSchemaUnsignedLong::ToDouble() const
{
	return IsEmpty() ? (double)0.0	: ICMapforceMachineUtil::InRangeDbl<double>((double)ICMapforceMachineUtil::InRangeInt<__int64>(m_Value, _I64_MIN, _I64_MAX), 1.7E-308, 1.7E+308); 	
}


template<>
inline void CSchemaInt::InternalNumParse(const TCHAR* szValue)
{
	m_Value = _ttol(szValue);
}

template<>
inline void CSchemaUnsignedInt::InternalNumParse(const TCHAR* szValue)
{
	m_Value = _ttol(szValue);
}

template<>
inline void CSchemaLong::InternalNumParse(const TCHAR* szValue)
{
	m_Value = _ttoi64(szValue);
}

template<>
inline void CSchemaUnsignedLong::InternalNumParse(const TCHAR* szValue)
{
	m_Value = _ttoi64(szValue);
}

template<>
inline void CSchemaFloat::InternalNumParse(const TCHAR* szValue)
{
	TCHAR* endptr;
	m_Value = (float)_tcstod(szValue, &endptr);
}

template<>
inline void CSchemaDouble::InternalNumParse(const TCHAR* szValue)
{
	TCHAR* endptr;
	m_Value = _tcstod(szValue, &endptr);
}

template<>
inline void CSchemaDecimal::InternalNumParse(const TCHAR* szValue)
{
	TCHAR* endptr;
	m_Value = _tcstod(szValue, &endptr);
}

template<>
inline CSchemaDecimal::operator	tstring() const
{
	if( IsEmpty() )
		return _T("");

	int nPrecision = 15;
	if ( m_Value != 0.0 )
	{
		//2^52 - 52 bits for mantissa
		//nPrecision = log10(4503599627370496) - log10(fabs(nNumber)) ;
		// seems so that MS rounds earlier so lets go for 51 bits 2^51 - 1
		nPrecision = int( log10(2251799813685247.0) - log10(fabs(m_Value)) );
	}
	
	if( nPrecision< 0 )
		nPrecision = 0;
	
	TCHAR szValue[48];
	_sntprintf( szValue, 48, _T("%.*lf"), nPrecision, m_Value );
	szValue[47] = 0;

	CSchemaTypeNumber::TruncTrailingZeros( &szValue[ 0 ] );
	return szValue;
}

////////////////////////////////////////////////////////////////////////
//
//  CSchemaBoolean
//
////////////////////////////////////////////////////////////////////////


class ALTOVA_DECLSPECIFIER CSchemaBoolean : public CSchemaTypeNumber, public CSchemaType
{
public:
	CSchemaBoolean() : m_Value( false )												{};
	CSchemaBoolean( const bool value) : m_Value( value != 0 )						{ SetIsEmpty( false ); };
	CSchemaBoolean( const TCHAR* szValue) : m_Value( false )						{ Parse(szValue); }
	CSchemaBoolean( const CSchemaType& rOther)										{ Assign( rOther ); }


	// Operators
	virtual operator								bool() const					{ return IsEmpty() ? false : m_Value; }
	long											ToCalcValue() const				{ return ToLong(); }
	virtual CSchemaBoolean& operator=(const bool bValue);
	virtual CSchemaBoolean& operator=(const CSchemaType& rOther)					{ return (CSchemaBoolean&)Assign(rOther); }

	// --------- Interface CSchemaType ----------
	// Operators
	virtual bool									ToBool() const;
	virtual operator								tstring() const;


	// Operations
	virtual void									Empty();
	virtual bool									Parse( const TCHAR* szValue );
	virtual CSchemaType&							Assign(const CSchemaType& rOther );

	virtual CSchemaTypeNumber*						GetSchemaTypeNumberPtr() const	{ return (CSchemaTypeNumber*)this; }

	// --------- Interface CSchemaTypeNumber ---------
	virtual ETypes									NumericType() const				{ return (CSchemaType::ETypes)TYPE; }
	virtual long									ToLong() const					{ return IsEmpty() ? (long)0	: m_Value; }
	virtual __int64									ToInt64() const					{ return IsEmpty() ? (__int64)0	: m_Value; }
	virtual float									ToFloat() const					{ return IsEmpty() ? (float)0.0	: m_Value; }
	virtual double									ToDouble() const				{ return IsEmpty() ? (double)0.0: m_Value; }

	enum { TYPE = CSchemaType::k_bool };
	typedef bool									basetype;
	typedef long									calctype;
	
protected:
	bool											m_Value;
};



} // namespace altova

#endif // ALTOVA_SCHEMATYPENUMBER_H_INCLUDED
