////////////////////////////////////////////////////////////////////////
//
// Node.h
//
// This file was generated by XMLSpy 2005 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#ifndef ALTOVA_NODE_H_INCLUDED
#define ALTOVA_NODE_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000


namespace altova {


class ALTOVA_DECLSPECIFIER CNode : public CBaseObject
{
public:
	typedef enum
	{
		Element,
		Attribute,
		Text,
		CData,
		Comment,
		ProcessingInstruction
	} ENodeType;

	typedef enum
	{
		eSequence,
		eAll,
		eChoice
	} EGroupType;

protected:
	CNode();
	CNode(xercesc::DOMNode* pThisNode);
	CNode(xercesc::DOMDocument* pDOMDocument);
	virtual ~CNode();

public:
	CNode& 					Assign(const CNode& other);
	tstring					GetNodeName();
	tstring					GetNodeValue();
	xercesc::DOMNode*		GetDOMNode();
	//EGroupType				GetGroupType() const = 0;
	void					MapPrefix(const tstring& sPrefix, const tstring& sURI);
	static bool				NamesMatch(xercesc::DOMNode* pNode, const tstring& sNamespaceURI, const tstring& sName);
	static tstring			GetNodeTextValue( xercesc::DOMNode* pNode );

protected:
	friend class CDoc;

	static tstring			InternalGetNodeValue(ENodeType eNodeType, xercesc::DOMNode* pNode);
	tstring					InternalGetElementValue();
	void					InternalSetElementValue(const tstring& sValue);
	static bool				InternalNamesMatch(xercesc::DOMNode* pNode, const tstring& sNamespaceURI, const tstring& sName);

	int						ChildCountInternal(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName);
	bool					InternalHasChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName);
	xercesc::DOMNode*		InternalCreate(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue);
	xercesc::DOMNode*		InternalAppend(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue);
	xercesc::DOMNode*		InternalAppendNode(const tstring& sNamespaceURI, const tstring& sName, CNode& rNode);
	xercesc::DOMNode*		InternalGetAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex);
	xercesc::DOMNode* 		InternalGetFirstChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName);
	xercesc::DOMNode* 		InternalGetNextChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, xercesc::DOMNode* pCurNode );

	xercesc::DOMNode*		InternalGet(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName);
	xercesc::DOMNode*		InternalInsertAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue);
	xercesc::DOMNode*		InternalInsertNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode);
	xercesc::DOMNode*		InternalReplaceAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue);
	xercesc::DOMNode*		InternalReplaceNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode);
	xercesc::DOMNode*		InternalRemoveAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex);

	xercesc::DOMElement*	InternalAdopt(xercesc::DOMNode* pElement, const tstring& sNamespaceURI, const tstring& sName);
	static void				DeclareNamespace(xercesc::DOMElement* pElement, const tstring& sPrefix, const tstring& sURI);
	static const XMLCh*		LookupPrefix(xercesc::DOMNode* pNode, const XMLCh* szURI);
	static void				InternalAdjustPrefix(xercesc::DOMNode* pDOMNode, bool bQualified);
	virtual void			AdjustPrefix() = 0;

	xercesc::DOMNode*		m_pDOMNode;
};


} // namespace altova


#endif // ALTOVA_NODE_H_INCLUDED
