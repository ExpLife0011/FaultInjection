////////////////////////////////////////////////////////////////////////
//
// FaultInjectionXML.cpp
//
// This file was generated by XMLSpy 2005 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include <xercesc/dom/DOM.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include <xercesc/sax/HandlerBase.hpp>
#include <xercesc/framework/LocalFileFormatTarget.hpp>

#include "../AltovaDll_Xerces_nomfc/Altova_Dll_Xerces_nomfc/Altova.h"
#include "../AltovaDll_Xerces_nomfc/Altova_Dll_Xerces_nomfc/SchemaTypes.h"
#include "../AltovaDll_Xerces_nomfc/Altova_Dll_Xerces_nomfc/AltovaException.h"
#include "../AltovaDll_Xerces_nomfc/Altova_Dll_Xerces_nomfc/SchemaTypeString.h"
#include "../AltovaDll_Xerces_nomfc/Altova_Dll_Xerces_nomfc/SchemaTypeNumber.h"
#include "../AltovaDll_Xerces_nomfc/Altova_Dll_Xerces_nomfc/SchemaTypeCalendar.h"
#include "../AltovaDll_Xerces_nomfc/Altova_Dll_Xerces_nomfc/SchemaTypeBinary.h"

#include "../AltovaDll_Xerces_nomfc/AltovaXML_Dll_Xerces_nomfc/XmlException.h"
#include "../AltovaDll_Xerces_nomfc/AltovaXML_Dll_Xerces_nomfc/Node.h"
#include "../AltovaDll_Xerces_nomfc/AltovaXML_Dll_Xerces_nomfc/Doc.h"
using namespace altova;

#include "FaultInjectionXML.h"

namespace NSFaultInjectionXML
{


void CFaultInjectionXMLDoc::DeclareNamespaces(xercesc::DOMElement* pElement)
{
}



////////////////////////////////////////////////////////////////////////
//
// class CServiceType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CServiceType::GetGroupType()
{
	return eSequence;
}

void CServiceType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("SvrName"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("SvrName"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CServiceType::GetIsInjectMinCount()
{
	return 0;
}


int CServiceType::GetIsInjectMaxCount()
{
	return 1;
}


int CServiceType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CServiceType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CServiceType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CServiceType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CServiceType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CServiceType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CServiceType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CServiceType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CServiceType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CServiceType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CServiceType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CServiceType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CServiceType::GetSvrNameMinCount()
{
	return 1;
}


int CServiceType::GetSvrNameMaxCount()
{
	return 1;
}


int CServiceType::GetSvrNameCount()
{
	return ChildCountInternal(Element, _T(""), _T("SvrName"));
}


bool CServiceType::HasSvrName()
{
	return InternalHasChild(Element, _T(""), _T("SvrName"));
}


void CServiceType::AddSvrName(CSchemaString SvrName)
{
	InternalAppend(Element, _T(""), _T("SvrName"), SvrName);
}


void CServiceType::InsertSvrNameAt(CSchemaString SvrName, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("SvrName"), nIndex, SvrName);
}


void CServiceType::ReplaceSvrNameAt(CSchemaString SvrName, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("SvrName"), nIndex, SvrName);
}



CSchemaString CServiceType::GetSvrNameAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("SvrName"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("SvrName"), nIndex));
}

xercesc::DOMNode* CServiceType::GetStartingSvrNameCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("SvrName"));
}

xercesc::DOMNode* CServiceType::GetAdvancedSvrNameCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("SvrName"), pCurNode);
}

CSchemaString CServiceType::GetSvrNameValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CServiceType::GetSvrName()
{
	return GetSvrNameAt(0);
}


void CServiceType::RemoveSvrNameAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("SvrName"), nIndex);
}


void CServiceType::RemoveSvrName()
{
	while (HasSvrName())
		RemoveSvrNameAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CServiceFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CServiceFaultType::GetGroupType()
{
	return eSequence;
}

void CServiceFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("Service"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Service"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CServiceType(pDOMNode).AdjustPrefix();
	}
}
int CServiceFaultType::GetServiceMinCount()
{
	return 1;
}


int CServiceFaultType::GetServiceMaxCount()
{
	return 1;
}


int CServiceFaultType::GetServiceCount()
{
	return ChildCountInternal(Element, _T(""), _T("Service"));
}


bool CServiceFaultType::HasService()
{
	return InternalHasChild(Element, _T(""), _T("Service"));
}


void CServiceFaultType::AddService(CServiceType& Service)
{
	InternalAppendNode(_T(""), _T("Service"), Service);
}


void CServiceFaultType::InsertServiceAt(CServiceType& Service, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("Service"), nIndex, Service);
}


void CServiceFaultType::ReplaceServiceAt(CServiceType& Service, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("Service"), nIndex, Service);
}



CServiceType CServiceFaultType::GetServiceAt(int nIndex)
{
	return CServiceType(InternalGetAt(Element, _T(""), _T("Service"), nIndex));
}

xercesc::DOMNode* CServiceFaultType::GetStartingServiceCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Service"));
}

xercesc::DOMNode* CServiceFaultType::GetAdvancedServiceCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Service"), pCurNode);
}

CServiceType CServiceFaultType::GetServiceValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CServiceType(pCurNode);
	}
}



CServiceType CServiceFaultType::GetService()
{
	return GetServiceAt(0);
}


void CServiceFaultType::RemoveServiceAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Service"), nIndex);
}


void CServiceFaultType::RemoveService()
{
	while (HasService())
		RemoveServiceAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CProcessType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CProcessType::GetGroupType()
{
	return eSequence;
}

void CProcessType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("ProcName"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("ProcName"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CProcessType::GetIsInjectMinCount()
{
	return 0;
}


int CProcessType::GetIsInjectMaxCount()
{
	return 1;
}


int CProcessType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CProcessType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CProcessType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CProcessType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CProcessType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CProcessType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CProcessType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CProcessType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CProcessType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CProcessType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CProcessType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CProcessType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CProcessType::GetProcNameMinCount()
{
	return 1;
}


int CProcessType::GetProcNameMaxCount()
{
	return 1;
}


int CProcessType::GetProcNameCount()
{
	return ChildCountInternal(Element, _T(""), _T("ProcName"));
}


bool CProcessType::HasProcName()
{
	return InternalHasChild(Element, _T(""), _T("ProcName"));
}


void CProcessType::AddProcName(CSchemaString ProcName)
{
	InternalAppend(Element, _T(""), _T("ProcName"), ProcName);
}


void CProcessType::InsertProcNameAt(CSchemaString ProcName, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("ProcName"), nIndex, ProcName);
}


void CProcessType::ReplaceProcNameAt(CSchemaString ProcName, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("ProcName"), nIndex, ProcName);
}



CSchemaString CProcessType::GetProcNameAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ProcName"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ProcName"), nIndex));
}

xercesc::DOMNode* CProcessType::GetStartingProcNameCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("ProcName"));
}

xercesc::DOMNode* CProcessType::GetAdvancedProcNameCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("ProcName"), pCurNode);
}

CSchemaString CProcessType::GetProcNameValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CProcessType::GetProcName()
{
	return GetProcNameAt(0);
}


void CProcessType::RemoveProcNameAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("ProcName"), nIndex);
}


void CProcessType::RemoveProcName()
{
	while (HasProcName())
		RemoveProcNameAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CProcessFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CProcessFaultType::GetGroupType()
{
	return eSequence;
}

void CProcessFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("Process"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Process"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CProcessType(pDOMNode).AdjustPrefix();
	}
}
int CProcessFaultType::GetProcessMinCount()
{
	return 1;
}


int CProcessFaultType::GetProcessMaxCount()
{
	return 1;
}


int CProcessFaultType::GetProcessCount()
{
	return ChildCountInternal(Element, _T(""), _T("Process"));
}


bool CProcessFaultType::HasProcess()
{
	return InternalHasChild(Element, _T(""), _T("Process"));
}


void CProcessFaultType::AddProcess(CProcessType& Process)
{
	InternalAppendNode(_T(""), _T("Process"), Process);
}


void CProcessFaultType::InsertProcessAt(CProcessType& Process, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("Process"), nIndex, Process);
}


void CProcessFaultType::ReplaceProcessAt(CProcessType& Process, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("Process"), nIndex, Process);
}



CProcessType CProcessFaultType::GetProcessAt(int nIndex)
{
	return CProcessType(InternalGetAt(Element, _T(""), _T("Process"), nIndex));
}

xercesc::DOMNode* CProcessFaultType::GetStartingProcessCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Process"));
}

xercesc::DOMNode* CProcessFaultType::GetAdvancedProcessCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Process"), pCurNode);
}

CProcessType CProcessFaultType::GetProcessValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CProcessType(pCurNode);
	}
}



CProcessType CProcessFaultType::GetProcess()
{
	return GetProcessAt(0);
}


void CProcessFaultType::RemoveProcessAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Process"), nIndex);
}


void CProcessFaultType::RemoveProcess()
{
	while (HasProcess())
		RemoveProcessAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CFaultItemType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CFaultItemType::GetGroupType()
{
	return eSequence;
}

void CFaultItemType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("ServiceFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("ServiceFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CServiceFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("ProcessFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("ProcessFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CProcessFaultType(pDOMNode).AdjustPrefix();
	}
}
int CFaultItemType::GetServiceFaultMinCount()
{
	return 1;
}


int CFaultItemType::GetServiceFaultMaxCount()
{
	return 1;
}


int CFaultItemType::GetServiceFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("ServiceFault"));
}


bool CFaultItemType::HasServiceFault()
{
	return InternalHasChild(Element, _T(""), _T("ServiceFault"));
}


void CFaultItemType::AddServiceFault(CServiceFaultType& ServiceFault)
{
	InternalAppendNode(_T(""), _T("ServiceFault"), ServiceFault);
}


void CFaultItemType::InsertServiceFaultAt(CServiceFaultType& ServiceFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("ServiceFault"), nIndex, ServiceFault);
}


void CFaultItemType::ReplaceServiceFaultAt(CServiceFaultType& ServiceFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("ServiceFault"), nIndex, ServiceFault);
}



CServiceFaultType CFaultItemType::GetServiceFaultAt(int nIndex)
{
	return CServiceFaultType(InternalGetAt(Element, _T(""), _T("ServiceFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType::GetStartingServiceFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("ServiceFault"));
}

xercesc::DOMNode* CFaultItemType::GetAdvancedServiceFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("ServiceFault"), pCurNode);
}

CServiceFaultType CFaultItemType::GetServiceFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CServiceFaultType(pCurNode);
	}
}



CServiceFaultType CFaultItemType::GetServiceFault()
{
	return GetServiceFaultAt(0);
}


void CFaultItemType::RemoveServiceFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("ServiceFault"), nIndex);
}


void CFaultItemType::RemoveServiceFault()
{
	while (HasServiceFault())
		RemoveServiceFaultAt(0);
}

int CFaultItemType::GetProcessFaultMinCount()
{
	return 1;
}


int CFaultItemType::GetProcessFaultMaxCount()
{
	return 1;
}


int CFaultItemType::GetProcessFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("ProcessFault"));
}


bool CFaultItemType::HasProcessFault()
{
	return InternalHasChild(Element, _T(""), _T("ProcessFault"));
}


void CFaultItemType::AddProcessFault(CProcessFaultType& ProcessFault)
{
	InternalAppendNode(_T(""), _T("ProcessFault"), ProcessFault);
}


void CFaultItemType::InsertProcessFaultAt(CProcessFaultType& ProcessFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("ProcessFault"), nIndex, ProcessFault);
}


void CFaultItemType::ReplaceProcessFaultAt(CProcessFaultType& ProcessFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("ProcessFault"), nIndex, ProcessFault);
}



CProcessFaultType CFaultItemType::GetProcessFaultAt(int nIndex)
{
	return CProcessFaultType(InternalGetAt(Element, _T(""), _T("ProcessFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType::GetStartingProcessFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("ProcessFault"));
}

xercesc::DOMNode* CFaultItemType::GetAdvancedProcessFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("ProcessFault"), pCurNode);
}

CProcessFaultType CFaultItemType::GetProcessFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CProcessFaultType(pCurNode);
	}
}



CProcessFaultType CFaultItemType::GetProcessFault()
{
	return GetProcessFaultAt(0);
}


void CFaultItemType::RemoveProcessFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("ProcessFault"), nIndex);
}


void CFaultItemType::RemoveProcessFault()
{
	while (HasProcessFault())
		RemoveProcessFaultAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CBasicServiceFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CBasicServiceFaultType::GetGroupType()
{
	return eSequence;
}

void CBasicServiceFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("StartTime"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("StartTime"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("EndTime"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("EndTime"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("FaultItem"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("FaultItem"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CFaultItemType(pDOMNode).AdjustPrefix();
	}
}
int CBasicServiceFaultType::GetStartTimeMinCount()
{
	return 0;
}


int CBasicServiceFaultType::GetStartTimeMaxCount()
{
	return 1;
}


int CBasicServiceFaultType::GetStartTimeCount()
{
	return ChildCountInternal(Element, _T(""), _T("StartTime"));
}


bool CBasicServiceFaultType::HasStartTime()
{
	return InternalHasChild(Element, _T(""), _T("StartTime"));
}


void CBasicServiceFaultType::AddStartTime(CSchemaDateTime StartTime)
{
	InternalAppend(Element, _T(""), _T("StartTime"), StartTime);
}


void CBasicServiceFaultType::InsertStartTimeAt(CSchemaDateTime StartTime, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("StartTime"), nIndex, StartTime);
}


void CBasicServiceFaultType::ReplaceStartTimeAt(CSchemaDateTime StartTime, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("StartTime"), nIndex, StartTime);
}



CSchemaDateTime CBasicServiceFaultType::GetStartTimeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("StartTime"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("StartTime"), nIndex));
}

xercesc::DOMNode* CBasicServiceFaultType::GetStartingStartTimeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("StartTime"));
}

xercesc::DOMNode* CBasicServiceFaultType::GetAdvancedStartTimeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("StartTime"), pCurNode);
}

CSchemaDateTime CBasicServiceFaultType::GetStartTimeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaDateTime CBasicServiceFaultType::GetStartTime()
{
	return GetStartTimeAt(0);
}


void CBasicServiceFaultType::RemoveStartTimeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("StartTime"), nIndex);
}


void CBasicServiceFaultType::RemoveStartTime()
{
	while (HasStartTime())
		RemoveStartTimeAt(0);
}

int CBasicServiceFaultType::GetEndTimeMinCount()
{
	return 0;
}


int CBasicServiceFaultType::GetEndTimeMaxCount()
{
	return 1;
}


int CBasicServiceFaultType::GetEndTimeCount()
{
	return ChildCountInternal(Element, _T(""), _T("EndTime"));
}


bool CBasicServiceFaultType::HasEndTime()
{
	return InternalHasChild(Element, _T(""), _T("EndTime"));
}


void CBasicServiceFaultType::AddEndTime(CSchemaDateTime EndTime)
{
	InternalAppend(Element, _T(""), _T("EndTime"), EndTime);
}


void CBasicServiceFaultType::InsertEndTimeAt(CSchemaDateTime EndTime, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("EndTime"), nIndex, EndTime);
}


void CBasicServiceFaultType::ReplaceEndTimeAt(CSchemaDateTime EndTime, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("EndTime"), nIndex, EndTime);
}



CSchemaDateTime CBasicServiceFaultType::GetEndTimeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("EndTime"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("EndTime"), nIndex));
}

xercesc::DOMNode* CBasicServiceFaultType::GetStartingEndTimeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("EndTime"));
}

xercesc::DOMNode* CBasicServiceFaultType::GetAdvancedEndTimeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("EndTime"), pCurNode);
}

CSchemaDateTime CBasicServiceFaultType::GetEndTimeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaDateTime CBasicServiceFaultType::GetEndTime()
{
	return GetEndTimeAt(0);
}


void CBasicServiceFaultType::RemoveEndTimeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("EndTime"), nIndex);
}


void CBasicServiceFaultType::RemoveEndTime()
{
	while (HasEndTime())
		RemoveEndTimeAt(0);
}

int CBasicServiceFaultType::GetFaultItemMinCount()
{
	return 1;
}


int CBasicServiceFaultType::GetFaultItemMaxCount()
{
	return 1;
}


int CBasicServiceFaultType::GetFaultItemCount()
{
	return ChildCountInternal(Element, _T(""), _T("FaultItem"));
}


bool CBasicServiceFaultType::HasFaultItem()
{
	return InternalHasChild(Element, _T(""), _T("FaultItem"));
}


void CBasicServiceFaultType::AddFaultItem(CFaultItemType& FaultItem)
{
	InternalAppendNode(_T(""), _T("FaultItem"), FaultItem);
}


void CBasicServiceFaultType::InsertFaultItemAt(CFaultItemType& FaultItem, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}


void CBasicServiceFaultType::ReplaceFaultItemAt(CFaultItemType& FaultItem, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}



CFaultItemType CBasicServiceFaultType::GetFaultItemAt(int nIndex)
{
	return CFaultItemType(InternalGetAt(Element, _T(""), _T("FaultItem"), nIndex));
}

xercesc::DOMNode* CBasicServiceFaultType::GetStartingFaultItemCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("FaultItem"));
}

xercesc::DOMNode* CBasicServiceFaultType::GetAdvancedFaultItemCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("FaultItem"), pCurNode);
}

CFaultItemType CBasicServiceFaultType::GetFaultItemValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CFaultItemType(pCurNode);
	}
}



CFaultItemType CBasicServiceFaultType::GetFaultItem()
{
	return GetFaultItemAt(0);
}


void CBasicServiceFaultType::RemoveFaultItemAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("FaultItem"), nIndex);
}


void CBasicServiceFaultType::RemoveFaultItem()
{
	while (HasFaultItem())
		RemoveFaultItemAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CDBConnectInfoType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CDBConnectInfoType::GetGroupType()
{
	return eSequence;
}

void CDBConnectInfoType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("DBName"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("DBName"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IP"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IP"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Port"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Port"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("ServerName"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("ServerName"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("UserName"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("UserName"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("PassWord"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("PassWord"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CDBConnectInfoType::GetDBNameMinCount()
{
	return 1;
}


int CDBConnectInfoType::GetDBNameMaxCount()
{
	return 1;
}


int CDBConnectInfoType::GetDBNameCount()
{
	return ChildCountInternal(Element, _T(""), _T("DBName"));
}


bool CDBConnectInfoType::HasDBName()
{
	return InternalHasChild(Element, _T(""), _T("DBName"));
}


void CDBConnectInfoType::AddDBName(CSchemaString DBName)
{
	InternalAppend(Element, _T(""), _T("DBName"), DBName);
}


void CDBConnectInfoType::InsertDBNameAt(CSchemaString DBName, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("DBName"), nIndex, DBName);
}


void CDBConnectInfoType::ReplaceDBNameAt(CSchemaString DBName, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("DBName"), nIndex, DBName);
}



CSchemaString CDBConnectInfoType::GetDBNameAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("DBName"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("DBName"), nIndex));
}

xercesc::DOMNode* CDBConnectInfoType::GetStartingDBNameCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("DBName"));
}

xercesc::DOMNode* CDBConnectInfoType::GetAdvancedDBNameCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("DBName"), pCurNode);
}

CSchemaString CDBConnectInfoType::GetDBNameValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CDBConnectInfoType::GetDBName()
{
	return GetDBNameAt(0);
}


void CDBConnectInfoType::RemoveDBNameAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("DBName"), nIndex);
}


void CDBConnectInfoType::RemoveDBName()
{
	while (HasDBName())
		RemoveDBNameAt(0);
}

int CDBConnectInfoType::GetIPMinCount()
{
	return 1;
}


int CDBConnectInfoType::GetIPMaxCount()
{
	return 1;
}


int CDBConnectInfoType::GetIPCount()
{
	return ChildCountInternal(Element, _T(""), _T("IP"));
}


bool CDBConnectInfoType::HasIP()
{
	return InternalHasChild(Element, _T(""), _T("IP"));
}


void CDBConnectInfoType::AddIP(CSchemaString IP)
{
	InternalAppend(Element, _T(""), _T("IP"), IP);
}


void CDBConnectInfoType::InsertIPAt(CSchemaString IP, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IP"), nIndex, IP);
}


void CDBConnectInfoType::ReplaceIPAt(CSchemaString IP, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IP"), nIndex, IP);
}



CSchemaString CDBConnectInfoType::GetIPAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IP"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IP"), nIndex));
}

xercesc::DOMNode* CDBConnectInfoType::GetStartingIPCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IP"));
}

xercesc::DOMNode* CDBConnectInfoType::GetAdvancedIPCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IP"), pCurNode);
}

CSchemaString CDBConnectInfoType::GetIPValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CDBConnectInfoType::GetIP()
{
	return GetIPAt(0);
}


void CDBConnectInfoType::RemoveIPAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IP"), nIndex);
}


void CDBConnectInfoType::RemoveIP()
{
	while (HasIP())
		RemoveIPAt(0);
}

int CDBConnectInfoType::GetPortMinCount()
{
	return 1;
}


int CDBConnectInfoType::GetPortMaxCount()
{
	return 1;
}


int CDBConnectInfoType::GetPortCount()
{
	return ChildCountInternal(Element, _T(""), _T("Port"));
}


bool CDBConnectInfoType::HasPort()
{
	return InternalHasChild(Element, _T(""), _T("Port"));
}


void CDBConnectInfoType::AddPort(CSchemaString Port)
{
	InternalAppend(Element, _T(""), _T("Port"), Port);
}


void CDBConnectInfoType::InsertPortAt(CSchemaString Port, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Port"), nIndex, Port);
}


void CDBConnectInfoType::ReplacePortAt(CSchemaString Port, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Port"), nIndex, Port);
}



CSchemaString CDBConnectInfoType::GetPortAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Port"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Port"), nIndex));
}

xercesc::DOMNode* CDBConnectInfoType::GetStartingPortCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Port"));
}

xercesc::DOMNode* CDBConnectInfoType::GetAdvancedPortCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Port"), pCurNode);
}

CSchemaString CDBConnectInfoType::GetPortValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CDBConnectInfoType::GetPort()
{
	return GetPortAt(0);
}


void CDBConnectInfoType::RemovePortAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Port"), nIndex);
}


void CDBConnectInfoType::RemovePort()
{
	while (HasPort())
		RemovePortAt(0);
}

int CDBConnectInfoType::GetServerNameMinCount()
{
	return 1;
}


int CDBConnectInfoType::GetServerNameMaxCount()
{
	return 1;
}


int CDBConnectInfoType::GetServerNameCount()
{
	return ChildCountInternal(Element, _T(""), _T("ServerName"));
}


bool CDBConnectInfoType::HasServerName()
{
	return InternalHasChild(Element, _T(""), _T("ServerName"));
}


void CDBConnectInfoType::AddServerName(CSchemaString ServerName)
{
	InternalAppend(Element, _T(""), _T("ServerName"), ServerName);
}


void CDBConnectInfoType::InsertServerNameAt(CSchemaString ServerName, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("ServerName"), nIndex, ServerName);
}


void CDBConnectInfoType::ReplaceServerNameAt(CSchemaString ServerName, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("ServerName"), nIndex, ServerName);
}



CSchemaString CDBConnectInfoType::GetServerNameAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ServerName"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ServerName"), nIndex));
}

xercesc::DOMNode* CDBConnectInfoType::GetStartingServerNameCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("ServerName"));
}

xercesc::DOMNode* CDBConnectInfoType::GetAdvancedServerNameCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("ServerName"), pCurNode);
}

CSchemaString CDBConnectInfoType::GetServerNameValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CDBConnectInfoType::GetServerName()
{
	return GetServerNameAt(0);
}


void CDBConnectInfoType::RemoveServerNameAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("ServerName"), nIndex);
}


void CDBConnectInfoType::RemoveServerName()
{
	while (HasServerName())
		RemoveServerNameAt(0);
}

int CDBConnectInfoType::GetUserNameMinCount()
{
	return 1;
}


int CDBConnectInfoType::GetUserNameMaxCount()
{
	return 1;
}


int CDBConnectInfoType::GetUserNameCount()
{
	return ChildCountInternal(Element, _T(""), _T("UserName"));
}


bool CDBConnectInfoType::HasUserName()
{
	return InternalHasChild(Element, _T(""), _T("UserName"));
}


void CDBConnectInfoType::AddUserName(CSchemaString UserName)
{
	InternalAppend(Element, _T(""), _T("UserName"), UserName);
}


void CDBConnectInfoType::InsertUserNameAt(CSchemaString UserName, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("UserName"), nIndex, UserName);
}


void CDBConnectInfoType::ReplaceUserNameAt(CSchemaString UserName, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("UserName"), nIndex, UserName);
}



CSchemaString CDBConnectInfoType::GetUserNameAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("UserName"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("UserName"), nIndex));
}

xercesc::DOMNode* CDBConnectInfoType::GetStartingUserNameCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("UserName"));
}

xercesc::DOMNode* CDBConnectInfoType::GetAdvancedUserNameCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("UserName"), pCurNode);
}

CSchemaString CDBConnectInfoType::GetUserNameValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CDBConnectInfoType::GetUserName()
{
	return GetUserNameAt(0);
}


void CDBConnectInfoType::RemoveUserNameAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("UserName"), nIndex);
}


void CDBConnectInfoType::RemoveUserName()
{
	while (HasUserName())
		RemoveUserNameAt(0);
}

int CDBConnectInfoType::GetPassWordMinCount()
{
	return 1;
}


int CDBConnectInfoType::GetPassWordMaxCount()
{
	return 1;
}


int CDBConnectInfoType::GetPassWordCount()
{
	return ChildCountInternal(Element, _T(""), _T("PassWord"));
}


bool CDBConnectInfoType::HasPassWord()
{
	return InternalHasChild(Element, _T(""), _T("PassWord"));
}


void CDBConnectInfoType::AddPassWord(CSchemaString PassWord)
{
	InternalAppend(Element, _T(""), _T("PassWord"), PassWord);
}


void CDBConnectInfoType::InsertPassWordAt(CSchemaString PassWord, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("PassWord"), nIndex, PassWord);
}


void CDBConnectInfoType::ReplacePassWordAt(CSchemaString PassWord, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("PassWord"), nIndex, PassWord);
}



CSchemaString CDBConnectInfoType::GetPassWordAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("PassWord"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("PassWord"), nIndex));
}

xercesc::DOMNode* CDBConnectInfoType::GetStartingPassWordCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("PassWord"));
}

xercesc::DOMNode* CDBConnectInfoType::GetAdvancedPassWordCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("PassWord"), pCurNode);
}

CSchemaString CDBConnectInfoType::GetPassWordValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CDBConnectInfoType::GetPassWord()
{
	return GetPassWordAt(0);
}


void CDBConnectInfoType::RemovePassWordAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("PassWord"), nIndex);
}


void CDBConnectInfoType::RemovePassWord()
{
	while (HasPassWord())
		RemovePassWordAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CPWFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CPWFaultType::GetGroupType()
{
	return eSequence;
}

void CPWFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("UserName"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("UserName"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("OldPW"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("OldPW"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("NewPW"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("NewPW"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CPWFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CPWFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CPWFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CPWFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CPWFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CPWFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CPWFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CPWFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CPWFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CPWFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CPWFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CPWFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CPWFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CPWFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CPWFaultType::GetUserNameMinCount()
{
	return 1;
}


int CPWFaultType::GetUserNameMaxCount()
{
	return 1;
}


int CPWFaultType::GetUserNameCount()
{
	return ChildCountInternal(Element, _T(""), _T("UserName"));
}


bool CPWFaultType::HasUserName()
{
	return InternalHasChild(Element, _T(""), _T("UserName"));
}


void CPWFaultType::AddUserName(CSchemaString UserName)
{
	InternalAppend(Element, _T(""), _T("UserName"), UserName);
}


void CPWFaultType::InsertUserNameAt(CSchemaString UserName, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("UserName"), nIndex, UserName);
}


void CPWFaultType::ReplaceUserNameAt(CSchemaString UserName, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("UserName"), nIndex, UserName);
}



CSchemaString CPWFaultType::GetUserNameAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("UserName"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("UserName"), nIndex));
}

xercesc::DOMNode* CPWFaultType::GetStartingUserNameCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("UserName"));
}

xercesc::DOMNode* CPWFaultType::GetAdvancedUserNameCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("UserName"), pCurNode);
}

CSchemaString CPWFaultType::GetUserNameValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CPWFaultType::GetUserName()
{
	return GetUserNameAt(0);
}


void CPWFaultType::RemoveUserNameAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("UserName"), nIndex);
}


void CPWFaultType::RemoveUserName()
{
	while (HasUserName())
		RemoveUserNameAt(0);
}

int CPWFaultType::GetOldPWMinCount()
{
	return 1;
}


int CPWFaultType::GetOldPWMaxCount()
{
	return 1;
}


int CPWFaultType::GetOldPWCount()
{
	return ChildCountInternal(Element, _T(""), _T("OldPW"));
}


bool CPWFaultType::HasOldPW()
{
	return InternalHasChild(Element, _T(""), _T("OldPW"));
}


void CPWFaultType::AddOldPW(CSchemaString OldPW)
{
	InternalAppend(Element, _T(""), _T("OldPW"), OldPW);
}


void CPWFaultType::InsertOldPWAt(CSchemaString OldPW, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("OldPW"), nIndex, OldPW);
}


void CPWFaultType::ReplaceOldPWAt(CSchemaString OldPW, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("OldPW"), nIndex, OldPW);
}



CSchemaString CPWFaultType::GetOldPWAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("OldPW"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("OldPW"), nIndex));
}

xercesc::DOMNode* CPWFaultType::GetStartingOldPWCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("OldPW"));
}

xercesc::DOMNode* CPWFaultType::GetAdvancedOldPWCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("OldPW"), pCurNode);
}

CSchemaString CPWFaultType::GetOldPWValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CPWFaultType::GetOldPW()
{
	return GetOldPWAt(0);
}


void CPWFaultType::RemoveOldPWAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("OldPW"), nIndex);
}


void CPWFaultType::RemoveOldPW()
{
	while (HasOldPW())
		RemoveOldPWAt(0);
}

int CPWFaultType::GetNewPWMinCount()
{
	return 1;
}


int CPWFaultType::GetNewPWMaxCount()
{
	return 1;
}


int CPWFaultType::GetNewPWCount()
{
	return ChildCountInternal(Element, _T(""), _T("NewPW"));
}


bool CPWFaultType::HasNewPW()
{
	return InternalHasChild(Element, _T(""), _T("NewPW"));
}


void CPWFaultType::AddNewPW(CSchemaString NewPW)
{
	InternalAppend(Element, _T(""), _T("NewPW"), NewPW);
}


void CPWFaultType::InsertNewPWAt(CSchemaString NewPW, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("NewPW"), nIndex, NewPW);
}


void CPWFaultType::ReplaceNewPWAt(CSchemaString NewPW, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("NewPW"), nIndex, NewPW);
}



CSchemaString CPWFaultType::GetNewPWAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("NewPW"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("NewPW"), nIndex));
}

xercesc::DOMNode* CPWFaultType::GetStartingNewPWCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("NewPW"));
}

xercesc::DOMNode* CPWFaultType::GetAdvancedNewPWCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("NewPW"), pCurNode);
}

CSchemaString CPWFaultType::GetNewPWValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CPWFaultType::GetNewPW()
{
	return GetNewPWAt(0);
}


void CPWFaultType::RemoveNewPWAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("NewPW"), nIndex);
}


void CPWFaultType::RemoveNewPW()
{
	while (HasNewPW())
		RemoveNewPWAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CTableFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CTableFaultType::GetGroupType()
{
	return eSequence;
}

void CTableFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("TableName"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("TableName"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CTableFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CTableFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CTableFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CTableFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CTableFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CTableFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CTableFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CTableFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CTableFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CTableFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CTableFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CTableFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CTableFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CTableFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CTableFaultType::GetTableNameMinCount()
{
	return 1;
}


int CTableFaultType::GetTableNameMaxCount()
{
	return 1;
}


int CTableFaultType::GetTableNameCount()
{
	return ChildCountInternal(Element, _T(""), _T("TableName"));
}


bool CTableFaultType::HasTableName()
{
	return InternalHasChild(Element, _T(""), _T("TableName"));
}


void CTableFaultType::AddTableName(CSchemaString TableName)
{
	InternalAppend(Element, _T(""), _T("TableName"), TableName);
}


void CTableFaultType::InsertTableNameAt(CSchemaString TableName, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("TableName"), nIndex, TableName);
}


void CTableFaultType::ReplaceTableNameAt(CSchemaString TableName, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("TableName"), nIndex, TableName);
}



CSchemaString CTableFaultType::GetTableNameAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("TableName"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("TableName"), nIndex));
}

xercesc::DOMNode* CTableFaultType::GetStartingTableNameCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("TableName"));
}

xercesc::DOMNode* CTableFaultType::GetAdvancedTableNameCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("TableName"), pCurNode);
}

CSchemaString CTableFaultType::GetTableNameValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CTableFaultType::GetTableName()
{
	return GetTableNameAt(0);
}


void CTableFaultType::RemoveTableNameAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("TableName"), nIndex);
}


void CTableFaultType::RemoveTableName()
{
	while (HasTableName())
		RemoveTableNameAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CFaultItemType2
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CFaultItemType2::GetGroupType()
{
	return eSequence;
}

void CFaultItemType2::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("DBType"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("DBType"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("DBConnectInfo"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("DBConnectInfo"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CDBConnectInfoType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("PWFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("PWFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CPWFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("TableFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("TableFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CTableFaultType(pDOMNode).AdjustPrefix();
	}
}
int CFaultItemType2::GetDBTypeMinCount()
{
	return 1;
}


int CFaultItemType2::GetDBTypeMaxCount()
{
	return 1;
}


int CFaultItemType2::GetDBTypeCount()
{
	return ChildCountInternal(Element, _T(""), _T("DBType"));
}


bool CFaultItemType2::HasDBType()
{
	return InternalHasChild(Element, _T(""), _T("DBType"));
}


void CFaultItemType2::AddDBType(CSchemaString DBType)
{
	InternalAppend(Element, _T(""), _T("DBType"), DBType);
}


void CFaultItemType2::InsertDBTypeAt(CSchemaString DBType, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("DBType"), nIndex, DBType);
}


void CFaultItemType2::ReplaceDBTypeAt(CSchemaString DBType, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("DBType"), nIndex, DBType);
}



CSchemaString CFaultItemType2::GetDBTypeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("DBType"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("DBType"), nIndex));
}

xercesc::DOMNode* CFaultItemType2::GetStartingDBTypeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("DBType"));
}

xercesc::DOMNode* CFaultItemType2::GetAdvancedDBTypeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("DBType"), pCurNode);
}

CSchemaString CFaultItemType2::GetDBTypeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CFaultItemType2::GetDBType()
{
	return GetDBTypeAt(0);
}


void CFaultItemType2::RemoveDBTypeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("DBType"), nIndex);
}


void CFaultItemType2::RemoveDBType()
{
	while (HasDBType())
		RemoveDBTypeAt(0);
}

int CFaultItemType2::GetDBConnectInfoMinCount()
{
	return 1;
}


int CFaultItemType2::GetDBConnectInfoMaxCount()
{
	return 1;
}


int CFaultItemType2::GetDBConnectInfoCount()
{
	return ChildCountInternal(Element, _T(""), _T("DBConnectInfo"));
}


bool CFaultItemType2::HasDBConnectInfo()
{
	return InternalHasChild(Element, _T(""), _T("DBConnectInfo"));
}


void CFaultItemType2::AddDBConnectInfo(CDBConnectInfoType& DBConnectInfo)
{
	InternalAppendNode(_T(""), _T("DBConnectInfo"), DBConnectInfo);
}


void CFaultItemType2::InsertDBConnectInfoAt(CDBConnectInfoType& DBConnectInfo, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("DBConnectInfo"), nIndex, DBConnectInfo);
}


void CFaultItemType2::ReplaceDBConnectInfoAt(CDBConnectInfoType& DBConnectInfo, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("DBConnectInfo"), nIndex, DBConnectInfo);
}



CDBConnectInfoType CFaultItemType2::GetDBConnectInfoAt(int nIndex)
{
	return CDBConnectInfoType(InternalGetAt(Element, _T(""), _T("DBConnectInfo"), nIndex));
}

xercesc::DOMNode* CFaultItemType2::GetStartingDBConnectInfoCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("DBConnectInfo"));
}

xercesc::DOMNode* CFaultItemType2::GetAdvancedDBConnectInfoCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("DBConnectInfo"), pCurNode);
}

CDBConnectInfoType CFaultItemType2::GetDBConnectInfoValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CDBConnectInfoType(pCurNode);
	}
}



CDBConnectInfoType CFaultItemType2::GetDBConnectInfo()
{
	return GetDBConnectInfoAt(0);
}


void CFaultItemType2::RemoveDBConnectInfoAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("DBConnectInfo"), nIndex);
}


void CFaultItemType2::RemoveDBConnectInfo()
{
	while (HasDBConnectInfo())
		RemoveDBConnectInfoAt(0);
}

int CFaultItemType2::GetPWFaultMinCount()
{
	return 1;
}


int CFaultItemType2::GetPWFaultMaxCount()
{
	return 1;
}


int CFaultItemType2::GetPWFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("PWFault"));
}


bool CFaultItemType2::HasPWFault()
{
	return InternalHasChild(Element, _T(""), _T("PWFault"));
}


void CFaultItemType2::AddPWFault(CPWFaultType& PWFault)
{
	InternalAppendNode(_T(""), _T("PWFault"), PWFault);
}


void CFaultItemType2::InsertPWFaultAt(CPWFaultType& PWFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("PWFault"), nIndex, PWFault);
}


void CFaultItemType2::ReplacePWFaultAt(CPWFaultType& PWFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("PWFault"), nIndex, PWFault);
}



CPWFaultType CFaultItemType2::GetPWFaultAt(int nIndex)
{
	return CPWFaultType(InternalGetAt(Element, _T(""), _T("PWFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType2::GetStartingPWFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("PWFault"));
}

xercesc::DOMNode* CFaultItemType2::GetAdvancedPWFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("PWFault"), pCurNode);
}

CPWFaultType CFaultItemType2::GetPWFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CPWFaultType(pCurNode);
	}
}



CPWFaultType CFaultItemType2::GetPWFault()
{
	return GetPWFaultAt(0);
}


void CFaultItemType2::RemovePWFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("PWFault"), nIndex);
}


void CFaultItemType2::RemovePWFault()
{
	while (HasPWFault())
		RemovePWFaultAt(0);
}

int CFaultItemType2::GetTableFaultMinCount()
{
	return 1;
}


int CFaultItemType2::GetTableFaultMaxCount()
{
	return 1;
}


int CFaultItemType2::GetTableFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("TableFault"));
}


bool CFaultItemType2::HasTableFault()
{
	return InternalHasChild(Element, _T(""), _T("TableFault"));
}


void CFaultItemType2::AddTableFault(CTableFaultType& TableFault)
{
	InternalAppendNode(_T(""), _T("TableFault"), TableFault);
}


void CFaultItemType2::InsertTableFaultAt(CTableFaultType& TableFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("TableFault"), nIndex, TableFault);
}


void CFaultItemType2::ReplaceTableFaultAt(CTableFaultType& TableFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("TableFault"), nIndex, TableFault);
}



CTableFaultType CFaultItemType2::GetTableFaultAt(int nIndex)
{
	return CTableFaultType(InternalGetAt(Element, _T(""), _T("TableFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType2::GetStartingTableFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("TableFault"));
}

xercesc::DOMNode* CFaultItemType2::GetAdvancedTableFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("TableFault"), pCurNode);
}

CTableFaultType CFaultItemType2::GetTableFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CTableFaultType(pCurNode);
	}
}



CTableFaultType CFaultItemType2::GetTableFault()
{
	return GetTableFaultAt(0);
}


void CFaultItemType2::RemoveTableFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("TableFault"), nIndex);
}


void CFaultItemType2::RemoveTableFault()
{
	while (HasTableFault())
		RemoveTableFaultAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CDBFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CDBFaultType::GetGroupType()
{
	return eSequence;
}

void CDBFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("FaultItem"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("FaultItem"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CFaultItemType2(pDOMNode).AdjustPrefix();
	}
}
int CDBFaultType::GetFaultItemMinCount()
{
	return 1;
}


int CDBFaultType::GetFaultItemMaxCount()
{
	return 1;
}


int CDBFaultType::GetFaultItemCount()
{
	return ChildCountInternal(Element, _T(""), _T("FaultItem"));
}


bool CDBFaultType::HasFaultItem()
{
	return InternalHasChild(Element, _T(""), _T("FaultItem"));
}


void CDBFaultType::AddFaultItem(CFaultItemType2& FaultItem)
{
	InternalAppendNode(_T(""), _T("FaultItem"), FaultItem);
}


void CDBFaultType::InsertFaultItemAt(CFaultItemType2& FaultItem, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}


void CDBFaultType::ReplaceFaultItemAt(CFaultItemType2& FaultItem, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}



CFaultItemType2 CDBFaultType::GetFaultItemAt(int nIndex)
{
	return CFaultItemType2(InternalGetAt(Element, _T(""), _T("FaultItem"), nIndex));
}

xercesc::DOMNode* CDBFaultType::GetStartingFaultItemCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("FaultItem"));
}

xercesc::DOMNode* CDBFaultType::GetAdvancedFaultItemCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("FaultItem"), pCurNode);
}

CFaultItemType2 CDBFaultType::GetFaultItemValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CFaultItemType2(pCurNode);
	}
}



CFaultItemType2 CDBFaultType::GetFaultItem()
{
	return GetFaultItemAt(0);
}


void CDBFaultType::RemoveFaultItemAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("FaultItem"), nIndex);
}


void CDBFaultType::RemoveFaultItem()
{
	while (HasFaultItem())
		RemoveFaultItemAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CCPUFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CCPUFaultType::GetGroupType()
{
	return eSequence;
}

void CCPUFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("CPUUsage"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("CPUUsage"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CCPUFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CCPUFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CCPUFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CCPUFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CCPUFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CCPUFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CCPUFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CCPUFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CCPUFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CCPUFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CCPUFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CCPUFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CCPUFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CCPUFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CCPUFaultType::GetCPUUsageMinCount()
{
	return 1;
}


int CCPUFaultType::GetCPUUsageMaxCount()
{
	return 1;
}


int CCPUFaultType::GetCPUUsageCount()
{
	return ChildCountInternal(Element, _T(""), _T("CPUUsage"));
}


bool CCPUFaultType::HasCPUUsage()
{
	return InternalHasChild(Element, _T(""), _T("CPUUsage"));
}


void CCPUFaultType::AddCPUUsage(CSchemaLong CPUUsage)
{
	InternalAppend(Element, _T(""), _T("CPUUsage"), CPUUsage);
}


void CCPUFaultType::InsertCPUUsageAt(CSchemaLong CPUUsage, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("CPUUsage"), nIndex, CPUUsage);
}


void CCPUFaultType::ReplaceCPUUsageAt(CSchemaLong CPUUsage, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("CPUUsage"), nIndex, CPUUsage);
}



CSchemaLong CCPUFaultType::GetCPUUsageAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("CPUUsage"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("CPUUsage"), nIndex));
}

xercesc::DOMNode* CCPUFaultType::GetStartingCPUUsageCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("CPUUsage"));
}

xercesc::DOMNode* CCPUFaultType::GetAdvancedCPUUsageCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("CPUUsage"), pCurNode);
}

CSchemaLong CCPUFaultType::GetCPUUsageValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CCPUFaultType::GetCPUUsage()
{
	return GetCPUUsageAt(0);
}


void CCPUFaultType::RemoveCPUUsageAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("CPUUsage"), nIndex);
}


void CCPUFaultType::RemoveCPUUsage()
{
	while (HasCPUUsage())
		RemoveCPUUsageAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CMEMFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CMEMFaultType::GetGroupType()
{
	return eSequence;
}

void CMEMFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("MEMUsage"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("MEMUsage"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CMEMFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CMEMFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CMEMFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CMEMFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CMEMFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CMEMFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CMEMFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CMEMFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CMEMFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CMEMFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CMEMFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CMEMFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CMEMFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CMEMFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CMEMFaultType::GetMEMUsageMinCount()
{
	return 1;
}


int CMEMFaultType::GetMEMUsageMaxCount()
{
	return 1;
}


int CMEMFaultType::GetMEMUsageCount()
{
	return ChildCountInternal(Element, _T(""), _T("MEMUsage"));
}


bool CMEMFaultType::HasMEMUsage()
{
	return InternalHasChild(Element, _T(""), _T("MEMUsage"));
}


void CMEMFaultType::AddMEMUsage(CSchemaLong MEMUsage)
{
	InternalAppend(Element, _T(""), _T("MEMUsage"), MEMUsage);
}


void CMEMFaultType::InsertMEMUsageAt(CSchemaLong MEMUsage, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("MEMUsage"), nIndex, MEMUsage);
}


void CMEMFaultType::ReplaceMEMUsageAt(CSchemaLong MEMUsage, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("MEMUsage"), nIndex, MEMUsage);
}



CSchemaLong CMEMFaultType::GetMEMUsageAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("MEMUsage"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("MEMUsage"), nIndex));
}

xercesc::DOMNode* CMEMFaultType::GetStartingMEMUsageCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("MEMUsage"));
}

xercesc::DOMNode* CMEMFaultType::GetAdvancedMEMUsageCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("MEMUsage"), pCurNode);
}

CSchemaLong CMEMFaultType::GetMEMUsageValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CMEMFaultType::GetMEMUsage()
{
	return GetMEMUsageAt(0);
}


void CMEMFaultType::RemoveMEMUsageAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("MEMUsage"), nIndex);
}


void CMEMFaultType::RemoveMEMUsage()
{
	while (HasMEMUsage())
		RemoveMEMUsageAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CDiskIOFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CDiskIOFaultType::GetGroupType()
{
	return eSequence;
}

void CDiskIOFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("WriteIOByte"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("WriteIOByte"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("ReadIOByte"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("ReadIOByte"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CDiskIOFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CDiskIOFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CDiskIOFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CDiskIOFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CDiskIOFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CDiskIOFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CDiskIOFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CDiskIOFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CDiskIOFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CDiskIOFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CDiskIOFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CDiskIOFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CDiskIOFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CDiskIOFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CDiskIOFaultType::GetWriteIOByteMinCount()
{
	return 1;
}


int CDiskIOFaultType::GetWriteIOByteMaxCount()
{
	return 1;
}


int CDiskIOFaultType::GetWriteIOByteCount()
{
	return ChildCountInternal(Element, _T(""), _T("WriteIOByte"));
}


bool CDiskIOFaultType::HasWriteIOByte()
{
	return InternalHasChild(Element, _T(""), _T("WriteIOByte"));
}


void CDiskIOFaultType::AddWriteIOByte(CSchemaLong WriteIOByte)
{
	InternalAppend(Element, _T(""), _T("WriteIOByte"), WriteIOByte);
}


void CDiskIOFaultType::InsertWriteIOByteAt(CSchemaLong WriteIOByte, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("WriteIOByte"), nIndex, WriteIOByte);
}


void CDiskIOFaultType::ReplaceWriteIOByteAt(CSchemaLong WriteIOByte, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("WriteIOByte"), nIndex, WriteIOByte);
}



CSchemaLong CDiskIOFaultType::GetWriteIOByteAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("WriteIOByte"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("WriteIOByte"), nIndex));
}

xercesc::DOMNode* CDiskIOFaultType::GetStartingWriteIOByteCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("WriteIOByte"));
}

xercesc::DOMNode* CDiskIOFaultType::GetAdvancedWriteIOByteCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("WriteIOByte"), pCurNode);
}

CSchemaLong CDiskIOFaultType::GetWriteIOByteValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CDiskIOFaultType::GetWriteIOByte()
{
	return GetWriteIOByteAt(0);
}


void CDiskIOFaultType::RemoveWriteIOByteAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("WriteIOByte"), nIndex);
}


void CDiskIOFaultType::RemoveWriteIOByte()
{
	while (HasWriteIOByte())
		RemoveWriteIOByteAt(0);
}

int CDiskIOFaultType::GetReadIOByteMinCount()
{
	return 1;
}


int CDiskIOFaultType::GetReadIOByteMaxCount()
{
	return 1;
}


int CDiskIOFaultType::GetReadIOByteCount()
{
	return ChildCountInternal(Element, _T(""), _T("ReadIOByte"));
}


bool CDiskIOFaultType::HasReadIOByte()
{
	return InternalHasChild(Element, _T(""), _T("ReadIOByte"));
}


void CDiskIOFaultType::AddReadIOByte(CSchemaLong ReadIOByte)
{
	InternalAppend(Element, _T(""), _T("ReadIOByte"), ReadIOByte);
}


void CDiskIOFaultType::InsertReadIOByteAt(CSchemaLong ReadIOByte, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("ReadIOByte"), nIndex, ReadIOByte);
}


void CDiskIOFaultType::ReplaceReadIOByteAt(CSchemaLong ReadIOByte, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("ReadIOByte"), nIndex, ReadIOByte);
}



CSchemaLong CDiskIOFaultType::GetReadIOByteAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ReadIOByte"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ReadIOByte"), nIndex));
}

xercesc::DOMNode* CDiskIOFaultType::GetStartingReadIOByteCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("ReadIOByte"));
}

xercesc::DOMNode* CDiskIOFaultType::GetAdvancedReadIOByteCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("ReadIOByte"), pCurNode);
}

CSchemaLong CDiskIOFaultType::GetReadIOByteValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CDiskIOFaultType::GetReadIOByte()
{
	return GetReadIOByteAt(0);
}


void CDiskIOFaultType::RemoveReadIOByteAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("ReadIOByte"), nIndex);
}


void CDiskIOFaultType::RemoveReadIOByte()
{
	while (HasReadIOByte())
		RemoveReadIOByteAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CFaultItemType3
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CFaultItemType3::GetGroupType()
{
	return eSequence;
}

void CFaultItemType3::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("CPUFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("CPUFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CCPUFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("MEMFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("MEMFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CMEMFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("DiskIOFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("DiskIOFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CDiskIOFaultType(pDOMNode).AdjustPrefix();
	}
}
int CFaultItemType3::GetCPUFaultMinCount()
{
	return 0;
}


int CFaultItemType3::GetCPUFaultMaxCount()
{
	return 1;
}


int CFaultItemType3::GetCPUFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("CPUFault"));
}


bool CFaultItemType3::HasCPUFault()
{
	return InternalHasChild(Element, _T(""), _T("CPUFault"));
}


void CFaultItemType3::AddCPUFault(CCPUFaultType& CPUFault)
{
	InternalAppendNode(_T(""), _T("CPUFault"), CPUFault);
}


void CFaultItemType3::InsertCPUFaultAt(CCPUFaultType& CPUFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("CPUFault"), nIndex, CPUFault);
}


void CFaultItemType3::ReplaceCPUFaultAt(CCPUFaultType& CPUFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("CPUFault"), nIndex, CPUFault);
}



CCPUFaultType CFaultItemType3::GetCPUFaultAt(int nIndex)
{
	return CCPUFaultType(InternalGetAt(Element, _T(""), _T("CPUFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType3::GetStartingCPUFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("CPUFault"));
}

xercesc::DOMNode* CFaultItemType3::GetAdvancedCPUFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("CPUFault"), pCurNode);
}

CCPUFaultType CFaultItemType3::GetCPUFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CCPUFaultType(pCurNode);
	}
}



CCPUFaultType CFaultItemType3::GetCPUFault()
{
	return GetCPUFaultAt(0);
}


void CFaultItemType3::RemoveCPUFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("CPUFault"), nIndex);
}


void CFaultItemType3::RemoveCPUFault()
{
	while (HasCPUFault())
		RemoveCPUFaultAt(0);
}

int CFaultItemType3::GetMEMFaultMinCount()
{
	return 0;
}


int CFaultItemType3::GetMEMFaultMaxCount()
{
	return 1;
}


int CFaultItemType3::GetMEMFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("MEMFault"));
}


bool CFaultItemType3::HasMEMFault()
{
	return InternalHasChild(Element, _T(""), _T("MEMFault"));
}


void CFaultItemType3::AddMEMFault(CMEMFaultType& MEMFault)
{
	InternalAppendNode(_T(""), _T("MEMFault"), MEMFault);
}


void CFaultItemType3::InsertMEMFaultAt(CMEMFaultType& MEMFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("MEMFault"), nIndex, MEMFault);
}


void CFaultItemType3::ReplaceMEMFaultAt(CMEMFaultType& MEMFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("MEMFault"), nIndex, MEMFault);
}



CMEMFaultType CFaultItemType3::GetMEMFaultAt(int nIndex)
{
	return CMEMFaultType(InternalGetAt(Element, _T(""), _T("MEMFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType3::GetStartingMEMFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("MEMFault"));
}

xercesc::DOMNode* CFaultItemType3::GetAdvancedMEMFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("MEMFault"), pCurNode);
}

CMEMFaultType CFaultItemType3::GetMEMFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CMEMFaultType(pCurNode);
	}
}



CMEMFaultType CFaultItemType3::GetMEMFault()
{
	return GetMEMFaultAt(0);
}


void CFaultItemType3::RemoveMEMFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("MEMFault"), nIndex);
}


void CFaultItemType3::RemoveMEMFault()
{
	while (HasMEMFault())
		RemoveMEMFaultAt(0);
}

int CFaultItemType3::GetDiskIOFaultMinCount()
{
	return 0;
}


int CFaultItemType3::GetDiskIOFaultMaxCount()
{
	return 1;
}


int CFaultItemType3::GetDiskIOFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("DiskIOFault"));
}


bool CFaultItemType3::HasDiskIOFault()
{
	return InternalHasChild(Element, _T(""), _T("DiskIOFault"));
}


void CFaultItemType3::AddDiskIOFault(CDiskIOFaultType& DiskIOFault)
{
	InternalAppendNode(_T(""), _T("DiskIOFault"), DiskIOFault);
}


void CFaultItemType3::InsertDiskIOFaultAt(CDiskIOFaultType& DiskIOFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("DiskIOFault"), nIndex, DiskIOFault);
}


void CFaultItemType3::ReplaceDiskIOFaultAt(CDiskIOFaultType& DiskIOFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("DiskIOFault"), nIndex, DiskIOFault);
}



CDiskIOFaultType CFaultItemType3::GetDiskIOFaultAt(int nIndex)
{
	return CDiskIOFaultType(InternalGetAt(Element, _T(""), _T("DiskIOFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType3::GetStartingDiskIOFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("DiskIOFault"));
}

xercesc::DOMNode* CFaultItemType3::GetAdvancedDiskIOFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("DiskIOFault"), pCurNode);
}

CDiskIOFaultType CFaultItemType3::GetDiskIOFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CDiskIOFaultType(pCurNode);
	}
}



CDiskIOFaultType CFaultItemType3::GetDiskIOFault()
{
	return GetDiskIOFaultAt(0);
}


void CFaultItemType3::RemoveDiskIOFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("DiskIOFault"), nIndex);
}


void CFaultItemType3::RemoveDiskIOFault()
{
	while (HasDiskIOFault())
		RemoveDiskIOFaultAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CHostFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CHostFaultType::GetGroupType()
{
	return eSequence;
}

void CHostFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("StartTime"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("StartTime"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("EndTime"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("EndTime"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("FaultItem"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("FaultItem"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CFaultItemType3(pDOMNode).AdjustPrefix();
	}
}
int CHostFaultType::GetStartTimeMinCount()
{
	return 0;
}


int CHostFaultType::GetStartTimeMaxCount()
{
	return 1;
}


int CHostFaultType::GetStartTimeCount()
{
	return ChildCountInternal(Element, _T(""), _T("StartTime"));
}


bool CHostFaultType::HasStartTime()
{
	return InternalHasChild(Element, _T(""), _T("StartTime"));
}


void CHostFaultType::AddStartTime(CSchemaDateTime StartTime)
{
	InternalAppend(Element, _T(""), _T("StartTime"), StartTime);
}


void CHostFaultType::InsertStartTimeAt(CSchemaDateTime StartTime, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("StartTime"), nIndex, StartTime);
}


void CHostFaultType::ReplaceStartTimeAt(CSchemaDateTime StartTime, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("StartTime"), nIndex, StartTime);
}



CSchemaDateTime CHostFaultType::GetStartTimeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("StartTime"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("StartTime"), nIndex));
}

xercesc::DOMNode* CHostFaultType::GetStartingStartTimeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("StartTime"));
}

xercesc::DOMNode* CHostFaultType::GetAdvancedStartTimeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("StartTime"), pCurNode);
}

CSchemaDateTime CHostFaultType::GetStartTimeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaDateTime CHostFaultType::GetStartTime()
{
	return GetStartTimeAt(0);
}


void CHostFaultType::RemoveStartTimeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("StartTime"), nIndex);
}


void CHostFaultType::RemoveStartTime()
{
	while (HasStartTime())
		RemoveStartTimeAt(0);
}

int CHostFaultType::GetEndTimeMinCount()
{
	return 0;
}


int CHostFaultType::GetEndTimeMaxCount()
{
	return 1;
}


int CHostFaultType::GetEndTimeCount()
{
	return ChildCountInternal(Element, _T(""), _T("EndTime"));
}


bool CHostFaultType::HasEndTime()
{
	return InternalHasChild(Element, _T(""), _T("EndTime"));
}


void CHostFaultType::AddEndTime(CSchemaDateTime EndTime)
{
	InternalAppend(Element, _T(""), _T("EndTime"), EndTime);
}


void CHostFaultType::InsertEndTimeAt(CSchemaDateTime EndTime, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("EndTime"), nIndex, EndTime);
}


void CHostFaultType::ReplaceEndTimeAt(CSchemaDateTime EndTime, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("EndTime"), nIndex, EndTime);
}



CSchemaDateTime CHostFaultType::GetEndTimeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("EndTime"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("EndTime"), nIndex));
}

xercesc::DOMNode* CHostFaultType::GetStartingEndTimeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("EndTime"));
}

xercesc::DOMNode* CHostFaultType::GetAdvancedEndTimeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("EndTime"), pCurNode);
}

CSchemaDateTime CHostFaultType::GetEndTimeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaDateTime CHostFaultType::GetEndTime()
{
	return GetEndTimeAt(0);
}


void CHostFaultType::RemoveEndTimeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("EndTime"), nIndex);
}


void CHostFaultType::RemoveEndTime()
{
	while (HasEndTime())
		RemoveEndTimeAt(0);
}

int CHostFaultType::GetFaultItemMinCount()
{
	return 1;
}


int CHostFaultType::GetFaultItemMaxCount()
{
	return 1;
}


int CHostFaultType::GetFaultItemCount()
{
	return ChildCountInternal(Element, _T(""), _T("FaultItem"));
}


bool CHostFaultType::HasFaultItem()
{
	return InternalHasChild(Element, _T(""), _T("FaultItem"));
}


void CHostFaultType::AddFaultItem(CFaultItemType3& FaultItem)
{
	InternalAppendNode(_T(""), _T("FaultItem"), FaultItem);
}


void CHostFaultType::InsertFaultItemAt(CFaultItemType3& FaultItem, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}


void CHostFaultType::ReplaceFaultItemAt(CFaultItemType3& FaultItem, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}



CFaultItemType3 CHostFaultType::GetFaultItemAt(int nIndex)
{
	return CFaultItemType3(InternalGetAt(Element, _T(""), _T("FaultItem"), nIndex));
}

xercesc::DOMNode* CHostFaultType::GetStartingFaultItemCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("FaultItem"));
}

xercesc::DOMNode* CHostFaultType::GetAdvancedFaultItemCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("FaultItem"), pCurNode);
}

CFaultItemType3 CHostFaultType::GetFaultItemValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CFaultItemType3(pCurNode);
	}
}



CFaultItemType3 CHostFaultType::GetFaultItem()
{
	return GetFaultItemAt(0);
}


void CHostFaultType::RemoveFaultItemAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("FaultItem"), nIndex);
}


void CHostFaultType::RemoveFaultItem()
{
	while (HasFaultItem())
		RemoveFaultItemAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CFilterType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CFilterType::GetGroupType()
{
	return eSequence;
}

void CFilterType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("Protocal"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Protocal"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IPScope"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IPScope"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("PortScope"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("PortScope"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CFilterType::GetProtocalMinCount()
{
	return 0;
}


int CFilterType::GetProtocalMaxCount()
{
	return 1;
}


int CFilterType::GetProtocalCount()
{
	return ChildCountInternal(Element, _T(""), _T("Protocal"));
}


bool CFilterType::HasProtocal()
{
	return InternalHasChild(Element, _T(""), _T("Protocal"));
}


void CFilterType::AddProtocal(CSchemaString Protocal)
{
	InternalAppend(Element, _T(""), _T("Protocal"), Protocal);
}


void CFilterType::InsertProtocalAt(CSchemaString Protocal, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Protocal"), nIndex, Protocal);
}


void CFilterType::ReplaceProtocalAt(CSchemaString Protocal, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Protocal"), nIndex, Protocal);
}



CSchemaString CFilterType::GetProtocalAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Protocal"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Protocal"), nIndex));
}

xercesc::DOMNode* CFilterType::GetStartingProtocalCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Protocal"));
}

xercesc::DOMNode* CFilterType::GetAdvancedProtocalCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Protocal"), pCurNode);
}

CSchemaString CFilterType::GetProtocalValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CFilterType::GetProtocal()
{
	return GetProtocalAt(0);
}


void CFilterType::RemoveProtocalAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Protocal"), nIndex);
}


void CFilterType::RemoveProtocal()
{
	while (HasProtocal())
		RemoveProtocalAt(0);
}

int CFilterType::GetIPScopeMinCount()
{
	return 0;
}


int CFilterType::GetIPScopeMaxCount()
{
	return 1;
}


int CFilterType::GetIPScopeCount()
{
	return ChildCountInternal(Element, _T(""), _T("IPScope"));
}


bool CFilterType::HasIPScope()
{
	return InternalHasChild(Element, _T(""), _T("IPScope"));
}


void CFilterType::AddIPScope(CSchemaString IPScope)
{
	InternalAppend(Element, _T(""), _T("IPScope"), IPScope);
}


void CFilterType::InsertIPScopeAt(CSchemaString IPScope, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IPScope"), nIndex, IPScope);
}


void CFilterType::ReplaceIPScopeAt(CSchemaString IPScope, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IPScope"), nIndex, IPScope);
}



CSchemaString CFilterType::GetIPScopeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IPScope"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IPScope"), nIndex));
}

xercesc::DOMNode* CFilterType::GetStartingIPScopeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IPScope"));
}

xercesc::DOMNode* CFilterType::GetAdvancedIPScopeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IPScope"), pCurNode);
}

CSchemaString CFilterType::GetIPScopeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CFilterType::GetIPScope()
{
	return GetIPScopeAt(0);
}


void CFilterType::RemoveIPScopeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IPScope"), nIndex);
}


void CFilterType::RemoveIPScope()
{
	while (HasIPScope())
		RemoveIPScopeAt(0);
}

int CFilterType::GetPortScopeMinCount()
{
	return 0;
}


int CFilterType::GetPortScopeMaxCount()
{
	return 1;
}


int CFilterType::GetPortScopeCount()
{
	return ChildCountInternal(Element, _T(""), _T("PortScope"));
}


bool CFilterType::HasPortScope()
{
	return InternalHasChild(Element, _T(""), _T("PortScope"));
}


void CFilterType::AddPortScope(CSchemaString PortScope)
{
	InternalAppend(Element, _T(""), _T("PortScope"), PortScope);
}


void CFilterType::InsertPortScopeAt(CSchemaString PortScope, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("PortScope"), nIndex, PortScope);
}


void CFilterType::ReplacePortScopeAt(CSchemaString PortScope, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("PortScope"), nIndex, PortScope);
}



CSchemaString CFilterType::GetPortScopeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("PortScope"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("PortScope"), nIndex));
}

xercesc::DOMNode* CFilterType::GetStartingPortScopeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("PortScope"));
}

xercesc::DOMNode* CFilterType::GetAdvancedPortScopeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("PortScope"), pCurNode);
}

CSchemaString CFilterType::GetPortScopeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CFilterType::GetPortScope()
{
	return GetPortScopeAt(0);
}


void CFilterType::RemovePortScopeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("PortScope"), nIndex);
}


void CFilterType::RemovePortScope()
{
	while (HasPortScope())
		RemovePortScopeAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CLagFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CLagFaultType::GetGroupType()
{
	return eSequence;
}

void CLagFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsInput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsInput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("lagTime"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("lagTime"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsOutput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsOutput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CLagFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CLagFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CLagFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CLagFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CLagFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CLagFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CLagFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CLagFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CLagFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CLagFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CLagFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CLagFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CLagFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CLagFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CLagFaultType::GetIsInputMinCount()
{
	return 1;
}


int CLagFaultType::GetIsInputMaxCount()
{
	return 1;
}


int CLagFaultType::GetIsInputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsInput"));
}


bool CLagFaultType::HasIsInput()
{
	return InternalHasChild(Element, _T(""), _T("IsInput"));
}


void CLagFaultType::AddIsInput(CSchemaBoolean IsInput)
{
	InternalAppend(Element, _T(""), _T("IsInput"), IsInput);
}


void CLagFaultType::InsertIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}


void CLagFaultType::ReplaceIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}



CSchemaBoolean CLagFaultType::GetIsInputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex));
}

xercesc::DOMNode* CLagFaultType::GetStartingIsInputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsInput"));
}

xercesc::DOMNode* CLagFaultType::GetAdvancedIsInputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsInput"), pCurNode);
}

CSchemaBoolean CLagFaultType::GetIsInputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CLagFaultType::GetIsInput()
{
	return GetIsInputAt(0);
}


void CLagFaultType::RemoveIsInputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsInput"), nIndex);
}


void CLagFaultType::RemoveIsInput()
{
	while (HasIsInput())
		RemoveIsInputAt(0);
}

int CLagFaultType::GetlagTimeMinCount()
{
	return 1;
}


int CLagFaultType::GetlagTimeMaxCount()
{
	return 1;
}


int CLagFaultType::GetlagTimeCount()
{
	return ChildCountInternal(Element, _T(""), _T("lagTime"));
}


bool CLagFaultType::HaslagTime()
{
	return InternalHasChild(Element, _T(""), _T("lagTime"));
}


void CLagFaultType::AddlagTime(CSchemaLong lagTime)
{
	InternalAppend(Element, _T(""), _T("lagTime"), lagTime);
}


void CLagFaultType::InsertlagTimeAt(CSchemaLong lagTime, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("lagTime"), nIndex, lagTime);
}


void CLagFaultType::ReplacelagTimeAt(CSchemaLong lagTime, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("lagTime"), nIndex, lagTime);
}



CSchemaLong CLagFaultType::GetlagTimeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("lagTime"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("lagTime"), nIndex));
}

xercesc::DOMNode* CLagFaultType::GetStartinglagTimeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("lagTime"));
}

xercesc::DOMNode* CLagFaultType::GetAdvancedlagTimeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("lagTime"), pCurNode);
}

CSchemaLong CLagFaultType::GetlagTimeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CLagFaultType::GetlagTime()
{
	return GetlagTimeAt(0);
}


void CLagFaultType::RemovelagTimeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("lagTime"), nIndex);
}


void CLagFaultType::RemovelagTime()
{
	while (HaslagTime())
		RemovelagTimeAt(0);
}

int CLagFaultType::GetIsOutputMinCount()
{
	return 1;
}


int CLagFaultType::GetIsOutputMaxCount()
{
	return 1;
}


int CLagFaultType::GetIsOutputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsOutput"));
}


bool CLagFaultType::HasIsOutput()
{
	return InternalHasChild(Element, _T(""), _T("IsOutput"));
}


void CLagFaultType::AddIsOutput(CSchemaBoolean IsOutput)
{
	InternalAppend(Element, _T(""), _T("IsOutput"), IsOutput);
}


void CLagFaultType::InsertIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}


void CLagFaultType::ReplaceIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}



CSchemaBoolean CLagFaultType::GetIsOutputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex));
}

xercesc::DOMNode* CLagFaultType::GetStartingIsOutputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsOutput"));
}

xercesc::DOMNode* CLagFaultType::GetAdvancedIsOutputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsOutput"), pCurNode);
}

CSchemaBoolean CLagFaultType::GetIsOutputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CLagFaultType::GetIsOutput()
{
	return GetIsOutputAt(0);
}


void CLagFaultType::RemoveIsOutputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsOutput"), nIndex);
}


void CLagFaultType::RemoveIsOutput()
{
	while (HasIsOutput())
		RemoveIsOutputAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CDropFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CDropFaultType::GetGroupType()
{
	return eSequence;
}

void CDropFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsInput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsInput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Rate"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Rate"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsOutput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsOutput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CDropFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CDropFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CDropFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CDropFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CDropFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CDropFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CDropFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CDropFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CDropFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CDropFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CDropFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CDropFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CDropFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CDropFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CDropFaultType::GetIsInputMinCount()
{
	return 1;
}


int CDropFaultType::GetIsInputMaxCount()
{
	return 1;
}


int CDropFaultType::GetIsInputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsInput"));
}


bool CDropFaultType::HasIsInput()
{
	return InternalHasChild(Element, _T(""), _T("IsInput"));
}


void CDropFaultType::AddIsInput(CSchemaBoolean IsInput)
{
	InternalAppend(Element, _T(""), _T("IsInput"), IsInput);
}


void CDropFaultType::InsertIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}


void CDropFaultType::ReplaceIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}



CSchemaBoolean CDropFaultType::GetIsInputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex));
}

xercesc::DOMNode* CDropFaultType::GetStartingIsInputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsInput"));
}

xercesc::DOMNode* CDropFaultType::GetAdvancedIsInputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsInput"), pCurNode);
}

CSchemaBoolean CDropFaultType::GetIsInputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CDropFaultType::GetIsInput()
{
	return GetIsInputAt(0);
}


void CDropFaultType::RemoveIsInputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsInput"), nIndex);
}


void CDropFaultType::RemoveIsInput()
{
	while (HasIsInput())
		RemoveIsInputAt(0);
}

int CDropFaultType::GetRateMinCount()
{
	return 1;
}


int CDropFaultType::GetRateMaxCount()
{
	return 1;
}


int CDropFaultType::GetRateCount()
{
	return ChildCountInternal(Element, _T(""), _T("Rate"));
}


bool CDropFaultType::HasRate()
{
	return InternalHasChild(Element, _T(""), _T("Rate"));
}


void CDropFaultType::AddRate(CSchemaLong Rate)
{
	InternalAppend(Element, _T(""), _T("Rate"), Rate);
}


void CDropFaultType::InsertRateAt(CSchemaLong Rate, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}


void CDropFaultType::ReplaceRateAt(CSchemaLong Rate, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}



CSchemaLong CDropFaultType::GetRateAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex));
}

xercesc::DOMNode* CDropFaultType::GetStartingRateCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Rate"));
}

xercesc::DOMNode* CDropFaultType::GetAdvancedRateCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Rate"), pCurNode);
}

CSchemaLong CDropFaultType::GetRateValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CDropFaultType::GetRate()
{
	return GetRateAt(0);
}


void CDropFaultType::RemoveRateAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Rate"), nIndex);
}


void CDropFaultType::RemoveRate()
{
	while (HasRate())
		RemoveRateAt(0);
}

int CDropFaultType::GetIsOutputMinCount()
{
	return 1;
}


int CDropFaultType::GetIsOutputMaxCount()
{
	return 1;
}


int CDropFaultType::GetIsOutputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsOutput"));
}


bool CDropFaultType::HasIsOutput()
{
	return InternalHasChild(Element, _T(""), _T("IsOutput"));
}


void CDropFaultType::AddIsOutput(CSchemaBoolean IsOutput)
{
	InternalAppend(Element, _T(""), _T("IsOutput"), IsOutput);
}


void CDropFaultType::InsertIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}


void CDropFaultType::ReplaceIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}



CSchemaBoolean CDropFaultType::GetIsOutputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex));
}

xercesc::DOMNode* CDropFaultType::GetStartingIsOutputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsOutput"));
}

xercesc::DOMNode* CDropFaultType::GetAdvancedIsOutputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsOutput"), pCurNode);
}

CSchemaBoolean CDropFaultType::GetIsOutputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CDropFaultType::GetIsOutput()
{
	return GetIsOutputAt(0);
}


void CDropFaultType::RemoveIsOutputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsOutput"), nIndex);
}


void CDropFaultType::RemoveIsOutput()
{
	while (HasIsOutput())
		RemoveIsOutputAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CThrottleFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CThrottleFaultType::GetGroupType()
{
	return eSequence;
}

void CThrottleFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsInput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsInput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Rate"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Rate"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Period"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Period"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsOutput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsOutput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CThrottleFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CThrottleFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CThrottleFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CThrottleFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CThrottleFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CThrottleFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CThrottleFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CThrottleFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CThrottleFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CThrottleFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CThrottleFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CThrottleFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CThrottleFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CThrottleFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CThrottleFaultType::GetIsInputMinCount()
{
	return 1;
}


int CThrottleFaultType::GetIsInputMaxCount()
{
	return 1;
}


int CThrottleFaultType::GetIsInputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsInput"));
}


bool CThrottleFaultType::HasIsInput()
{
	return InternalHasChild(Element, _T(""), _T("IsInput"));
}


void CThrottleFaultType::AddIsInput(CSchemaBoolean IsInput)
{
	InternalAppend(Element, _T(""), _T("IsInput"), IsInput);
}


void CThrottleFaultType::InsertIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}


void CThrottleFaultType::ReplaceIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}



CSchemaBoolean CThrottleFaultType::GetIsInputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex));
}

xercesc::DOMNode* CThrottleFaultType::GetStartingIsInputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsInput"));
}

xercesc::DOMNode* CThrottleFaultType::GetAdvancedIsInputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsInput"), pCurNode);
}

CSchemaBoolean CThrottleFaultType::GetIsInputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CThrottleFaultType::GetIsInput()
{
	return GetIsInputAt(0);
}


void CThrottleFaultType::RemoveIsInputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsInput"), nIndex);
}


void CThrottleFaultType::RemoveIsInput()
{
	while (HasIsInput())
		RemoveIsInputAt(0);
}

int CThrottleFaultType::GetRateMinCount()
{
	return 1;
}


int CThrottleFaultType::GetRateMaxCount()
{
	return 1;
}


int CThrottleFaultType::GetRateCount()
{
	return ChildCountInternal(Element, _T(""), _T("Rate"));
}


bool CThrottleFaultType::HasRate()
{
	return InternalHasChild(Element, _T(""), _T("Rate"));
}


void CThrottleFaultType::AddRate(CSchemaLong Rate)
{
	InternalAppend(Element, _T(""), _T("Rate"), Rate);
}


void CThrottleFaultType::InsertRateAt(CSchemaLong Rate, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}


void CThrottleFaultType::ReplaceRateAt(CSchemaLong Rate, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}



CSchemaLong CThrottleFaultType::GetRateAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex));
}

xercesc::DOMNode* CThrottleFaultType::GetStartingRateCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Rate"));
}

xercesc::DOMNode* CThrottleFaultType::GetAdvancedRateCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Rate"), pCurNode);
}

CSchemaLong CThrottleFaultType::GetRateValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CThrottleFaultType::GetRate()
{
	return GetRateAt(0);
}


void CThrottleFaultType::RemoveRateAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Rate"), nIndex);
}


void CThrottleFaultType::RemoveRate()
{
	while (HasRate())
		RemoveRateAt(0);
}

int CThrottleFaultType::GetPeriodMinCount()
{
	return 1;
}


int CThrottleFaultType::GetPeriodMaxCount()
{
	return 1;
}


int CThrottleFaultType::GetPeriodCount()
{
	return ChildCountInternal(Element, _T(""), _T("Period"));
}


bool CThrottleFaultType::HasPeriod()
{
	return InternalHasChild(Element, _T(""), _T("Period"));
}


void CThrottleFaultType::AddPeriod(CSchemaLong Period)
{
	InternalAppend(Element, _T(""), _T("Period"), Period);
}


void CThrottleFaultType::InsertPeriodAt(CSchemaLong Period, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Period"), nIndex, Period);
}


void CThrottleFaultType::ReplacePeriodAt(CSchemaLong Period, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Period"), nIndex, Period);
}



CSchemaLong CThrottleFaultType::GetPeriodAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Period"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Period"), nIndex));
}

xercesc::DOMNode* CThrottleFaultType::GetStartingPeriodCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Period"));
}

xercesc::DOMNode* CThrottleFaultType::GetAdvancedPeriodCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Period"), pCurNode);
}

CSchemaLong CThrottleFaultType::GetPeriodValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CThrottleFaultType::GetPeriod()
{
	return GetPeriodAt(0);
}


void CThrottleFaultType::RemovePeriodAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Period"), nIndex);
}


void CThrottleFaultType::RemovePeriod()
{
	while (HasPeriod())
		RemovePeriodAt(0);
}

int CThrottleFaultType::GetIsOutputMinCount()
{
	return 1;
}


int CThrottleFaultType::GetIsOutputMaxCount()
{
	return 1;
}


int CThrottleFaultType::GetIsOutputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsOutput"));
}


bool CThrottleFaultType::HasIsOutput()
{
	return InternalHasChild(Element, _T(""), _T("IsOutput"));
}


void CThrottleFaultType::AddIsOutput(CSchemaBoolean IsOutput)
{
	InternalAppend(Element, _T(""), _T("IsOutput"), IsOutput);
}


void CThrottleFaultType::InsertIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}


void CThrottleFaultType::ReplaceIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}



CSchemaBoolean CThrottleFaultType::GetIsOutputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex));
}

xercesc::DOMNode* CThrottleFaultType::GetStartingIsOutputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsOutput"));
}

xercesc::DOMNode* CThrottleFaultType::GetAdvancedIsOutputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsOutput"), pCurNode);
}

CSchemaBoolean CThrottleFaultType::GetIsOutputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CThrottleFaultType::GetIsOutput()
{
	return GetIsOutputAt(0);
}


void CThrottleFaultType::RemoveIsOutputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsOutput"), nIndex);
}


void CThrottleFaultType::RemoveIsOutput()
{
	while (HasIsOutput())
		RemoveIsOutputAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CDuplicateFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CDuplicateFaultType::GetGroupType()
{
	return eSequence;
}

void CDuplicateFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsInput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsInput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Rate"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Rate"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Times"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Times"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsOutput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsOutput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CDuplicateFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CDuplicateFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CDuplicateFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CDuplicateFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CDuplicateFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CDuplicateFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CDuplicateFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CDuplicateFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CDuplicateFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CDuplicateFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CDuplicateFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CDuplicateFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CDuplicateFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CDuplicateFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CDuplicateFaultType::GetIsInputMinCount()
{
	return 1;
}


int CDuplicateFaultType::GetIsInputMaxCount()
{
	return 1;
}


int CDuplicateFaultType::GetIsInputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsInput"));
}


bool CDuplicateFaultType::HasIsInput()
{
	return InternalHasChild(Element, _T(""), _T("IsInput"));
}


void CDuplicateFaultType::AddIsInput(CSchemaBoolean IsInput)
{
	InternalAppend(Element, _T(""), _T("IsInput"), IsInput);
}


void CDuplicateFaultType::InsertIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}


void CDuplicateFaultType::ReplaceIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}



CSchemaBoolean CDuplicateFaultType::GetIsInputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex));
}

xercesc::DOMNode* CDuplicateFaultType::GetStartingIsInputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsInput"));
}

xercesc::DOMNode* CDuplicateFaultType::GetAdvancedIsInputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsInput"), pCurNode);
}

CSchemaBoolean CDuplicateFaultType::GetIsInputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CDuplicateFaultType::GetIsInput()
{
	return GetIsInputAt(0);
}


void CDuplicateFaultType::RemoveIsInputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsInput"), nIndex);
}


void CDuplicateFaultType::RemoveIsInput()
{
	while (HasIsInput())
		RemoveIsInputAt(0);
}

int CDuplicateFaultType::GetRateMinCount()
{
	return 1;
}


int CDuplicateFaultType::GetRateMaxCount()
{
	return 1;
}


int CDuplicateFaultType::GetRateCount()
{
	return ChildCountInternal(Element, _T(""), _T("Rate"));
}


bool CDuplicateFaultType::HasRate()
{
	return InternalHasChild(Element, _T(""), _T("Rate"));
}


void CDuplicateFaultType::AddRate(CSchemaLong Rate)
{
	InternalAppend(Element, _T(""), _T("Rate"), Rate);
}


void CDuplicateFaultType::InsertRateAt(CSchemaLong Rate, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}


void CDuplicateFaultType::ReplaceRateAt(CSchemaLong Rate, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}



CSchemaLong CDuplicateFaultType::GetRateAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex));
}

xercesc::DOMNode* CDuplicateFaultType::GetStartingRateCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Rate"));
}

xercesc::DOMNode* CDuplicateFaultType::GetAdvancedRateCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Rate"), pCurNode);
}

CSchemaLong CDuplicateFaultType::GetRateValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CDuplicateFaultType::GetRate()
{
	return GetRateAt(0);
}


void CDuplicateFaultType::RemoveRateAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Rate"), nIndex);
}


void CDuplicateFaultType::RemoveRate()
{
	while (HasRate())
		RemoveRateAt(0);
}

int CDuplicateFaultType::GetTimesMinCount()
{
	return 1;
}


int CDuplicateFaultType::GetTimesMaxCount()
{
	return 1;
}


int CDuplicateFaultType::GetTimesCount()
{
	return ChildCountInternal(Element, _T(""), _T("Times"));
}


bool CDuplicateFaultType::HasTimes()
{
	return InternalHasChild(Element, _T(""), _T("Times"));
}


void CDuplicateFaultType::AddTimes(CSchemaLong Times)
{
	InternalAppend(Element, _T(""), _T("Times"), Times);
}


void CDuplicateFaultType::InsertTimesAt(CSchemaLong Times, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Times"), nIndex, Times);
}


void CDuplicateFaultType::ReplaceTimesAt(CSchemaLong Times, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Times"), nIndex, Times);
}



CSchemaLong CDuplicateFaultType::GetTimesAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Times"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Times"), nIndex));
}

xercesc::DOMNode* CDuplicateFaultType::GetStartingTimesCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Times"));
}

xercesc::DOMNode* CDuplicateFaultType::GetAdvancedTimesCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Times"), pCurNode);
}

CSchemaLong CDuplicateFaultType::GetTimesValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CDuplicateFaultType::GetTimes()
{
	return GetTimesAt(0);
}


void CDuplicateFaultType::RemoveTimesAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Times"), nIndex);
}


void CDuplicateFaultType::RemoveTimes()
{
	while (HasTimes())
		RemoveTimesAt(0);
}

int CDuplicateFaultType::GetIsOutputMinCount()
{
	return 1;
}


int CDuplicateFaultType::GetIsOutputMaxCount()
{
	return 1;
}


int CDuplicateFaultType::GetIsOutputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsOutput"));
}


bool CDuplicateFaultType::HasIsOutput()
{
	return InternalHasChild(Element, _T(""), _T("IsOutput"));
}


void CDuplicateFaultType::AddIsOutput(CSchemaBoolean IsOutput)
{
	InternalAppend(Element, _T(""), _T("IsOutput"), IsOutput);
}


void CDuplicateFaultType::InsertIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}


void CDuplicateFaultType::ReplaceIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}



CSchemaBoolean CDuplicateFaultType::GetIsOutputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex));
}

xercesc::DOMNode* CDuplicateFaultType::GetStartingIsOutputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsOutput"));
}

xercesc::DOMNode* CDuplicateFaultType::GetAdvancedIsOutputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsOutput"), pCurNode);
}

CSchemaBoolean CDuplicateFaultType::GetIsOutputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CDuplicateFaultType::GetIsOutput()
{
	return GetIsOutputAt(0);
}


void CDuplicateFaultType::RemoveIsOutputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsOutput"), nIndex);
}


void CDuplicateFaultType::RemoveIsOutput()
{
	while (HasIsOutput())
		RemoveIsOutputAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class COutOfOrderFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType COutOfOrderFaultType::GetGroupType()
{
	return eSequence;
}

void COutOfOrderFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsInput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsInput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Rate"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Rate"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsOutput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsOutput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int COutOfOrderFaultType::GetIsInjectMinCount()
{
	return 0;
}


int COutOfOrderFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int COutOfOrderFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool COutOfOrderFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void COutOfOrderFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void COutOfOrderFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void COutOfOrderFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean COutOfOrderFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* COutOfOrderFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* COutOfOrderFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean COutOfOrderFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean COutOfOrderFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void COutOfOrderFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void COutOfOrderFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int COutOfOrderFaultType::GetIsInputMinCount()
{
	return 1;
}


int COutOfOrderFaultType::GetIsInputMaxCount()
{
	return 1;
}


int COutOfOrderFaultType::GetIsInputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsInput"));
}


bool COutOfOrderFaultType::HasIsInput()
{
	return InternalHasChild(Element, _T(""), _T("IsInput"));
}


void COutOfOrderFaultType::AddIsInput(CSchemaBoolean IsInput)
{
	InternalAppend(Element, _T(""), _T("IsInput"), IsInput);
}


void COutOfOrderFaultType::InsertIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}


void COutOfOrderFaultType::ReplaceIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}



CSchemaBoolean COutOfOrderFaultType::GetIsInputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex));
}

xercesc::DOMNode* COutOfOrderFaultType::GetStartingIsInputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsInput"));
}

xercesc::DOMNode* COutOfOrderFaultType::GetAdvancedIsInputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsInput"), pCurNode);
}

CSchemaBoolean COutOfOrderFaultType::GetIsInputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean COutOfOrderFaultType::GetIsInput()
{
	return GetIsInputAt(0);
}


void COutOfOrderFaultType::RemoveIsInputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsInput"), nIndex);
}


void COutOfOrderFaultType::RemoveIsInput()
{
	while (HasIsInput())
		RemoveIsInputAt(0);
}

int COutOfOrderFaultType::GetRateMinCount()
{
	return 1;
}


int COutOfOrderFaultType::GetRateMaxCount()
{
	return 1;
}


int COutOfOrderFaultType::GetRateCount()
{
	return ChildCountInternal(Element, _T(""), _T("Rate"));
}


bool COutOfOrderFaultType::HasRate()
{
	return InternalHasChild(Element, _T(""), _T("Rate"));
}


void COutOfOrderFaultType::AddRate(CSchemaLong Rate)
{
	InternalAppend(Element, _T(""), _T("Rate"), Rate);
}


void COutOfOrderFaultType::InsertRateAt(CSchemaLong Rate, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}


void COutOfOrderFaultType::ReplaceRateAt(CSchemaLong Rate, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}



CSchemaLong COutOfOrderFaultType::GetRateAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex));
}

xercesc::DOMNode* COutOfOrderFaultType::GetStartingRateCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Rate"));
}

xercesc::DOMNode* COutOfOrderFaultType::GetAdvancedRateCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Rate"), pCurNode);
}

CSchemaLong COutOfOrderFaultType::GetRateValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong COutOfOrderFaultType::GetRate()
{
	return GetRateAt(0);
}


void COutOfOrderFaultType::RemoveRateAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Rate"), nIndex);
}


void COutOfOrderFaultType::RemoveRate()
{
	while (HasRate())
		RemoveRateAt(0);
}

int COutOfOrderFaultType::GetIsOutputMinCount()
{
	return 1;
}


int COutOfOrderFaultType::GetIsOutputMaxCount()
{
	return 1;
}


int COutOfOrderFaultType::GetIsOutputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsOutput"));
}


bool COutOfOrderFaultType::HasIsOutput()
{
	return InternalHasChild(Element, _T(""), _T("IsOutput"));
}


void COutOfOrderFaultType::AddIsOutput(CSchemaBoolean IsOutput)
{
	InternalAppend(Element, _T(""), _T("IsOutput"), IsOutput);
}


void COutOfOrderFaultType::InsertIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}


void COutOfOrderFaultType::ReplaceIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}



CSchemaBoolean COutOfOrderFaultType::GetIsOutputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex));
}

xercesc::DOMNode* COutOfOrderFaultType::GetStartingIsOutputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsOutput"));
}

xercesc::DOMNode* COutOfOrderFaultType::GetAdvancedIsOutputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsOutput"), pCurNode);
}

CSchemaBoolean COutOfOrderFaultType::GetIsOutputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean COutOfOrderFaultType::GetIsOutput()
{
	return GetIsOutputAt(0);
}


void COutOfOrderFaultType::RemoveIsOutputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsOutput"), nIndex);
}


void COutOfOrderFaultType::RemoveIsOutput()
{
	while (HasIsOutput())
		RemoveIsOutputAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CTamperFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CTamperFaultType::GetGroupType()
{
	return eSequence;
}

void CTamperFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsInput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsInput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Rate"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Rate"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsRewrite"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsRewrite"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("IsOutput"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("IsOutput"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CTamperFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CTamperFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CTamperFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CTamperFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CTamperFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CTamperFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CTamperFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CTamperFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CTamperFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CTamperFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CTamperFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CTamperFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CTamperFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CTamperFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CTamperFaultType::GetIsInputMinCount()
{
	return 1;
}


int CTamperFaultType::GetIsInputMaxCount()
{
	return 1;
}


int CTamperFaultType::GetIsInputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsInput"));
}


bool CTamperFaultType::HasIsInput()
{
	return InternalHasChild(Element, _T(""), _T("IsInput"));
}


void CTamperFaultType::AddIsInput(CSchemaBoolean IsInput)
{
	InternalAppend(Element, _T(""), _T("IsInput"), IsInput);
}


void CTamperFaultType::InsertIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}


void CTamperFaultType::ReplaceIsInputAt(CSchemaBoolean IsInput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsInput"), nIndex, IsInput);
}



CSchemaBoolean CTamperFaultType::GetIsInputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsInput"), nIndex));
}

xercesc::DOMNode* CTamperFaultType::GetStartingIsInputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsInput"));
}

xercesc::DOMNode* CTamperFaultType::GetAdvancedIsInputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsInput"), pCurNode);
}

CSchemaBoolean CTamperFaultType::GetIsInputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CTamperFaultType::GetIsInput()
{
	return GetIsInputAt(0);
}


void CTamperFaultType::RemoveIsInputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsInput"), nIndex);
}


void CTamperFaultType::RemoveIsInput()
{
	while (HasIsInput())
		RemoveIsInputAt(0);
}

int CTamperFaultType::GetRateMinCount()
{
	return 1;
}


int CTamperFaultType::GetRateMaxCount()
{
	return 1;
}


int CTamperFaultType::GetRateCount()
{
	return ChildCountInternal(Element, _T(""), _T("Rate"));
}


bool CTamperFaultType::HasRate()
{
	return InternalHasChild(Element, _T(""), _T("Rate"));
}


void CTamperFaultType::AddRate(CSchemaLong Rate)
{
	InternalAppend(Element, _T(""), _T("Rate"), Rate);
}


void CTamperFaultType::InsertRateAt(CSchemaLong Rate, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}


void CTamperFaultType::ReplaceRateAt(CSchemaLong Rate, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Rate"), nIndex, Rate);
}



CSchemaLong CTamperFaultType::GetRateAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Rate"), nIndex));
}

xercesc::DOMNode* CTamperFaultType::GetStartingRateCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Rate"));
}

xercesc::DOMNode* CTamperFaultType::GetAdvancedRateCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Rate"), pCurNode);
}

CSchemaLong CTamperFaultType::GetRateValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CTamperFaultType::GetRate()
{
	return GetRateAt(0);
}


void CTamperFaultType::RemoveRateAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Rate"), nIndex);
}


void CTamperFaultType::RemoveRate()
{
	while (HasRate())
		RemoveRateAt(0);
}

int CTamperFaultType::GetIsRewriteMinCount()
{
	return 1;
}


int CTamperFaultType::GetIsRewriteMaxCount()
{
	return 1;
}


int CTamperFaultType::GetIsRewriteCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsRewrite"));
}


bool CTamperFaultType::HasIsRewrite()
{
	return InternalHasChild(Element, _T(""), _T("IsRewrite"));
}


void CTamperFaultType::AddIsRewrite(CSchemaBoolean IsRewrite)
{
	InternalAppend(Element, _T(""), _T("IsRewrite"), IsRewrite);
}


void CTamperFaultType::InsertIsRewriteAt(CSchemaBoolean IsRewrite, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsRewrite"), nIndex, IsRewrite);
}


void CTamperFaultType::ReplaceIsRewriteAt(CSchemaBoolean IsRewrite, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsRewrite"), nIndex, IsRewrite);
}



CSchemaBoolean CTamperFaultType::GetIsRewriteAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsRewrite"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsRewrite"), nIndex));
}

xercesc::DOMNode* CTamperFaultType::GetStartingIsRewriteCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsRewrite"));
}

xercesc::DOMNode* CTamperFaultType::GetAdvancedIsRewriteCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsRewrite"), pCurNode);
}

CSchemaBoolean CTamperFaultType::GetIsRewriteValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CTamperFaultType::GetIsRewrite()
{
	return GetIsRewriteAt(0);
}


void CTamperFaultType::RemoveIsRewriteAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsRewrite"), nIndex);
}


void CTamperFaultType::RemoveIsRewrite()
{
	while (HasIsRewrite())
		RemoveIsRewriteAt(0);
}

int CTamperFaultType::GetIsOutputMinCount()
{
	return 1;
}


int CTamperFaultType::GetIsOutputMaxCount()
{
	return 1;
}


int CTamperFaultType::GetIsOutputCount()
{
	return ChildCountInternal(Element, _T(""), _T("IsOutput"));
}


bool CTamperFaultType::HasIsOutput()
{
	return InternalHasChild(Element, _T(""), _T("IsOutput"));
}


void CTamperFaultType::AddIsOutput(CSchemaBoolean IsOutput)
{
	InternalAppend(Element, _T(""), _T("IsOutput"), IsOutput);
}


void CTamperFaultType::InsertIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}


void CTamperFaultType::ReplaceIsOutputAt(CSchemaBoolean IsOutput, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("IsOutput"), nIndex, IsOutput);
}



CSchemaBoolean CTamperFaultType::GetIsOutputAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("IsOutput"), nIndex));
}

xercesc::DOMNode* CTamperFaultType::GetStartingIsOutputCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("IsOutput"));
}

xercesc::DOMNode* CTamperFaultType::GetAdvancedIsOutputCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("IsOutput"), pCurNode);
}

CSchemaBoolean CTamperFaultType::GetIsOutputValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CTamperFaultType::GetIsOutput()
{
	return GetIsOutputAt(0);
}


void CTamperFaultType::RemoveIsOutputAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("IsOutput"), nIndex);
}


void CTamperFaultType::RemoveIsOutput()
{
	while (HasIsOutput())
		RemoveIsOutputAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CFaultItemType4
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CFaultItemType4::GetGroupType()
{
	return eSequence;
}

void CFaultItemType4::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("LagFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("LagFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CLagFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("DropFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("DropFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CDropFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("ThrottleFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("ThrottleFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CThrottleFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("DuplicateFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("DuplicateFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CDuplicateFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("OutOfOrderFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("OutOfOrderFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		COutOfOrderFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("TamperFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("TamperFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CTamperFaultType(pDOMNode).AdjustPrefix();
	}
}
int CFaultItemType4::GetLagFaultMinCount()
{
	return 1;
}


int CFaultItemType4::GetLagFaultMaxCount()
{
	return 1;
}


int CFaultItemType4::GetLagFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("LagFault"));
}


bool CFaultItemType4::HasLagFault()
{
	return InternalHasChild(Element, _T(""), _T("LagFault"));
}


void CFaultItemType4::AddLagFault(CLagFaultType& LagFault)
{
	InternalAppendNode(_T(""), _T("LagFault"), LagFault);
}


void CFaultItemType4::InsertLagFaultAt(CLagFaultType& LagFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("LagFault"), nIndex, LagFault);
}


void CFaultItemType4::ReplaceLagFaultAt(CLagFaultType& LagFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("LagFault"), nIndex, LagFault);
}



CLagFaultType CFaultItemType4::GetLagFaultAt(int nIndex)
{
	return CLagFaultType(InternalGetAt(Element, _T(""), _T("LagFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType4::GetStartingLagFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("LagFault"));
}

xercesc::DOMNode* CFaultItemType4::GetAdvancedLagFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("LagFault"), pCurNode);
}

CLagFaultType CFaultItemType4::GetLagFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CLagFaultType(pCurNode);
	}
}



CLagFaultType CFaultItemType4::GetLagFault()
{
	return GetLagFaultAt(0);
}


void CFaultItemType4::RemoveLagFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("LagFault"), nIndex);
}


void CFaultItemType4::RemoveLagFault()
{
	while (HasLagFault())
		RemoveLagFaultAt(0);
}

int CFaultItemType4::GetDropFaultMinCount()
{
	return 1;
}


int CFaultItemType4::GetDropFaultMaxCount()
{
	return 1;
}


int CFaultItemType4::GetDropFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("DropFault"));
}


bool CFaultItemType4::HasDropFault()
{
	return InternalHasChild(Element, _T(""), _T("DropFault"));
}


void CFaultItemType4::AddDropFault(CDropFaultType& DropFault)
{
	InternalAppendNode(_T(""), _T("DropFault"), DropFault);
}


void CFaultItemType4::InsertDropFaultAt(CDropFaultType& DropFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("DropFault"), nIndex, DropFault);
}


void CFaultItemType4::ReplaceDropFaultAt(CDropFaultType& DropFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("DropFault"), nIndex, DropFault);
}



CDropFaultType CFaultItemType4::GetDropFaultAt(int nIndex)
{
	return CDropFaultType(InternalGetAt(Element, _T(""), _T("DropFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType4::GetStartingDropFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("DropFault"));
}

xercesc::DOMNode* CFaultItemType4::GetAdvancedDropFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("DropFault"), pCurNode);
}

CDropFaultType CFaultItemType4::GetDropFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CDropFaultType(pCurNode);
	}
}



CDropFaultType CFaultItemType4::GetDropFault()
{
	return GetDropFaultAt(0);
}


void CFaultItemType4::RemoveDropFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("DropFault"), nIndex);
}


void CFaultItemType4::RemoveDropFault()
{
	while (HasDropFault())
		RemoveDropFaultAt(0);
}

int CFaultItemType4::GetThrottleFaultMinCount()
{
	return 1;
}


int CFaultItemType4::GetThrottleFaultMaxCount()
{
	return 1;
}


int CFaultItemType4::GetThrottleFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("ThrottleFault"));
}


bool CFaultItemType4::HasThrottleFault()
{
	return InternalHasChild(Element, _T(""), _T("ThrottleFault"));
}


void CFaultItemType4::AddThrottleFault(CThrottleFaultType& ThrottleFault)
{
	InternalAppendNode(_T(""), _T("ThrottleFault"), ThrottleFault);
}


void CFaultItemType4::InsertThrottleFaultAt(CThrottleFaultType& ThrottleFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("ThrottleFault"), nIndex, ThrottleFault);
}


void CFaultItemType4::ReplaceThrottleFaultAt(CThrottleFaultType& ThrottleFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("ThrottleFault"), nIndex, ThrottleFault);
}



CThrottleFaultType CFaultItemType4::GetThrottleFaultAt(int nIndex)
{
	return CThrottleFaultType(InternalGetAt(Element, _T(""), _T("ThrottleFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType4::GetStartingThrottleFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("ThrottleFault"));
}

xercesc::DOMNode* CFaultItemType4::GetAdvancedThrottleFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("ThrottleFault"), pCurNode);
}

CThrottleFaultType CFaultItemType4::GetThrottleFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CThrottleFaultType(pCurNode);
	}
}



CThrottleFaultType CFaultItemType4::GetThrottleFault()
{
	return GetThrottleFaultAt(0);
}


void CFaultItemType4::RemoveThrottleFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("ThrottleFault"), nIndex);
}


void CFaultItemType4::RemoveThrottleFault()
{
	while (HasThrottleFault())
		RemoveThrottleFaultAt(0);
}

int CFaultItemType4::GetDuplicateFaultMinCount()
{
	return 1;
}


int CFaultItemType4::GetDuplicateFaultMaxCount()
{
	return 1;
}


int CFaultItemType4::GetDuplicateFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("DuplicateFault"));
}


bool CFaultItemType4::HasDuplicateFault()
{
	return InternalHasChild(Element, _T(""), _T("DuplicateFault"));
}


void CFaultItemType4::AddDuplicateFault(CDuplicateFaultType& DuplicateFault)
{
	InternalAppendNode(_T(""), _T("DuplicateFault"), DuplicateFault);
}


void CFaultItemType4::InsertDuplicateFaultAt(CDuplicateFaultType& DuplicateFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("DuplicateFault"), nIndex, DuplicateFault);
}


void CFaultItemType4::ReplaceDuplicateFaultAt(CDuplicateFaultType& DuplicateFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("DuplicateFault"), nIndex, DuplicateFault);
}



CDuplicateFaultType CFaultItemType4::GetDuplicateFaultAt(int nIndex)
{
	return CDuplicateFaultType(InternalGetAt(Element, _T(""), _T("DuplicateFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType4::GetStartingDuplicateFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("DuplicateFault"));
}

xercesc::DOMNode* CFaultItemType4::GetAdvancedDuplicateFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("DuplicateFault"), pCurNode);
}

CDuplicateFaultType CFaultItemType4::GetDuplicateFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CDuplicateFaultType(pCurNode);
	}
}



CDuplicateFaultType CFaultItemType4::GetDuplicateFault()
{
	return GetDuplicateFaultAt(0);
}


void CFaultItemType4::RemoveDuplicateFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("DuplicateFault"), nIndex);
}


void CFaultItemType4::RemoveDuplicateFault()
{
	while (HasDuplicateFault())
		RemoveDuplicateFaultAt(0);
}

int CFaultItemType4::GetOutOfOrderFaultMinCount()
{
	return 1;
}


int CFaultItemType4::GetOutOfOrderFaultMaxCount()
{
	return 1;
}


int CFaultItemType4::GetOutOfOrderFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("OutOfOrderFault"));
}


bool CFaultItemType4::HasOutOfOrderFault()
{
	return InternalHasChild(Element, _T(""), _T("OutOfOrderFault"));
}


void CFaultItemType4::AddOutOfOrderFault(COutOfOrderFaultType& OutOfOrderFault)
{
	InternalAppendNode(_T(""), _T("OutOfOrderFault"), OutOfOrderFault);
}


void CFaultItemType4::InsertOutOfOrderFaultAt(COutOfOrderFaultType& OutOfOrderFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("OutOfOrderFault"), nIndex, OutOfOrderFault);
}


void CFaultItemType4::ReplaceOutOfOrderFaultAt(COutOfOrderFaultType& OutOfOrderFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("OutOfOrderFault"), nIndex, OutOfOrderFault);
}



COutOfOrderFaultType CFaultItemType4::GetOutOfOrderFaultAt(int nIndex)
{
	return COutOfOrderFaultType(InternalGetAt(Element, _T(""), _T("OutOfOrderFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType4::GetStartingOutOfOrderFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("OutOfOrderFault"));
}

xercesc::DOMNode* CFaultItemType4::GetAdvancedOutOfOrderFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("OutOfOrderFault"), pCurNode);
}

COutOfOrderFaultType CFaultItemType4::GetOutOfOrderFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return COutOfOrderFaultType(pCurNode);
	}
}



COutOfOrderFaultType CFaultItemType4::GetOutOfOrderFault()
{
	return GetOutOfOrderFaultAt(0);
}


void CFaultItemType4::RemoveOutOfOrderFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("OutOfOrderFault"), nIndex);
}


void CFaultItemType4::RemoveOutOfOrderFault()
{
	while (HasOutOfOrderFault())
		RemoveOutOfOrderFaultAt(0);
}

int CFaultItemType4::GetTamperFaultMinCount()
{
	return 1;
}


int CFaultItemType4::GetTamperFaultMaxCount()
{
	return 1;
}


int CFaultItemType4::GetTamperFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("TamperFault"));
}


bool CFaultItemType4::HasTamperFault()
{
	return InternalHasChild(Element, _T(""), _T("TamperFault"));
}


void CFaultItemType4::AddTamperFault(CTamperFaultType& TamperFault)
{
	InternalAppendNode(_T(""), _T("TamperFault"), TamperFault);
}


void CFaultItemType4::InsertTamperFaultAt(CTamperFaultType& TamperFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("TamperFault"), nIndex, TamperFault);
}


void CFaultItemType4::ReplaceTamperFaultAt(CTamperFaultType& TamperFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("TamperFault"), nIndex, TamperFault);
}



CTamperFaultType CFaultItemType4::GetTamperFaultAt(int nIndex)
{
	return CTamperFaultType(InternalGetAt(Element, _T(""), _T("TamperFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType4::GetStartingTamperFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("TamperFault"));
}

xercesc::DOMNode* CFaultItemType4::GetAdvancedTamperFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("TamperFault"), pCurNode);
}

CTamperFaultType CFaultItemType4::GetTamperFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CTamperFaultType(pCurNode);
	}
}



CTamperFaultType CFaultItemType4::GetTamperFault()
{
	return GetTamperFaultAt(0);
}


void CFaultItemType4::RemoveTamperFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("TamperFault"), nIndex);
}


void CFaultItemType4::RemoveTamperFault()
{
	while (HasTamperFault())
		RemoveTamperFaultAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CNetWokFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CNetWokFaultType::GetGroupType()
{
	return eSequence;
}

void CNetWokFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("StartTime"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("StartTime"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("EndTime"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("EndTime"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Filter"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Filter"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CFilterType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("FaultItem"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("FaultItem"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CFaultItemType4(pDOMNode).AdjustPrefix();
	}
}
int CNetWokFaultType::GetStartTimeMinCount()
{
	return 0;
}


int CNetWokFaultType::GetStartTimeMaxCount()
{
	return 1;
}


int CNetWokFaultType::GetStartTimeCount()
{
	return ChildCountInternal(Element, _T(""), _T("StartTime"));
}


bool CNetWokFaultType::HasStartTime()
{
	return InternalHasChild(Element, _T(""), _T("StartTime"));
}


void CNetWokFaultType::AddStartTime(CSchemaDateTime StartTime)
{
	InternalAppend(Element, _T(""), _T("StartTime"), StartTime);
}


void CNetWokFaultType::InsertStartTimeAt(CSchemaDateTime StartTime, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("StartTime"), nIndex, StartTime);
}


void CNetWokFaultType::ReplaceStartTimeAt(CSchemaDateTime StartTime, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("StartTime"), nIndex, StartTime);
}



CSchemaDateTime CNetWokFaultType::GetStartTimeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("StartTime"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("StartTime"), nIndex));
}

xercesc::DOMNode* CNetWokFaultType::GetStartingStartTimeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("StartTime"));
}

xercesc::DOMNode* CNetWokFaultType::GetAdvancedStartTimeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("StartTime"), pCurNode);
}

CSchemaDateTime CNetWokFaultType::GetStartTimeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaDateTime CNetWokFaultType::GetStartTime()
{
	return GetStartTimeAt(0);
}


void CNetWokFaultType::RemoveStartTimeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("StartTime"), nIndex);
}


void CNetWokFaultType::RemoveStartTime()
{
	while (HasStartTime())
		RemoveStartTimeAt(0);
}

int CNetWokFaultType::GetEndTimeMinCount()
{
	return 0;
}


int CNetWokFaultType::GetEndTimeMaxCount()
{
	return 1;
}


int CNetWokFaultType::GetEndTimeCount()
{
	return ChildCountInternal(Element, _T(""), _T("EndTime"));
}


bool CNetWokFaultType::HasEndTime()
{
	return InternalHasChild(Element, _T(""), _T("EndTime"));
}


void CNetWokFaultType::AddEndTime(CSchemaDateTime EndTime)
{
	InternalAppend(Element, _T(""), _T("EndTime"), EndTime);
}


void CNetWokFaultType::InsertEndTimeAt(CSchemaDateTime EndTime, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("EndTime"), nIndex, EndTime);
}


void CNetWokFaultType::ReplaceEndTimeAt(CSchemaDateTime EndTime, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("EndTime"), nIndex, EndTime);
}



CSchemaDateTime CNetWokFaultType::GetEndTimeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("EndTime"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("EndTime"), nIndex));
}

xercesc::DOMNode* CNetWokFaultType::GetStartingEndTimeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("EndTime"));
}

xercesc::DOMNode* CNetWokFaultType::GetAdvancedEndTimeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("EndTime"), pCurNode);
}

CSchemaDateTime CNetWokFaultType::GetEndTimeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaDateTime CNetWokFaultType::GetEndTime()
{
	return GetEndTimeAt(0);
}


void CNetWokFaultType::RemoveEndTimeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("EndTime"), nIndex);
}


void CNetWokFaultType::RemoveEndTime()
{
	while (HasEndTime())
		RemoveEndTimeAt(0);
}

int CNetWokFaultType::GetFilterMinCount()
{
	return 1;
}


int CNetWokFaultType::GetFilterMaxCount()
{
	return 1;
}


int CNetWokFaultType::GetFilterCount()
{
	return ChildCountInternal(Element, _T(""), _T("Filter"));
}


bool CNetWokFaultType::HasFilter()
{
	return InternalHasChild(Element, _T(""), _T("Filter"));
}


void CNetWokFaultType::AddFilter(CFilterType& Filter)
{
	InternalAppendNode(_T(""), _T("Filter"), Filter);
}


void CNetWokFaultType::InsertFilterAt(CFilterType& Filter, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("Filter"), nIndex, Filter);
}


void CNetWokFaultType::ReplaceFilterAt(CFilterType& Filter, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("Filter"), nIndex, Filter);
}



CFilterType CNetWokFaultType::GetFilterAt(int nIndex)
{
	return CFilterType(InternalGetAt(Element, _T(""), _T("Filter"), nIndex));
}

xercesc::DOMNode* CNetWokFaultType::GetStartingFilterCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Filter"));
}

xercesc::DOMNode* CNetWokFaultType::GetAdvancedFilterCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Filter"), pCurNode);
}

CFilterType CNetWokFaultType::GetFilterValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CFilterType(pCurNode);
	}
}



CFilterType CNetWokFaultType::GetFilter()
{
	return GetFilterAt(0);
}


void CNetWokFaultType::RemoveFilterAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Filter"), nIndex);
}


void CNetWokFaultType::RemoveFilter()
{
	while (HasFilter())
		RemoveFilterAt(0);
}

int CNetWokFaultType::GetFaultItemMinCount()
{
	return 1;
}


int CNetWokFaultType::GetFaultItemMaxCount()
{
	return 1;
}


int CNetWokFaultType::GetFaultItemCount()
{
	return ChildCountInternal(Element, _T(""), _T("FaultItem"));
}


bool CNetWokFaultType::HasFaultItem()
{
	return InternalHasChild(Element, _T(""), _T("FaultItem"));
}


void CNetWokFaultType::AddFaultItem(CFaultItemType4& FaultItem)
{
	InternalAppendNode(_T(""), _T("FaultItem"), FaultItem);
}


void CNetWokFaultType::InsertFaultItemAt(CFaultItemType4& FaultItem, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}


void CNetWokFaultType::ReplaceFaultItemAt(CFaultItemType4& FaultItem, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}



CFaultItemType4 CNetWokFaultType::GetFaultItemAt(int nIndex)
{
	return CFaultItemType4(InternalGetAt(Element, _T(""), _T("FaultItem"), nIndex));
}

xercesc::DOMNode* CNetWokFaultType::GetStartingFaultItemCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("FaultItem"));
}

xercesc::DOMNode* CNetWokFaultType::GetAdvancedFaultItemCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("FaultItem"), pCurNode);
}

CFaultItemType4 CNetWokFaultType::GetFaultItemValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CFaultItemType4(pCurNode);
	}
}



CFaultItemType4 CNetWokFaultType::GetFaultItem()
{
	return GetFaultItemAt(0);
}


void CNetWokFaultType::RemoveFaultItemAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("FaultItem"), nIndex);
}


void CNetWokFaultType::RemoveFaultItem()
{
	while (HasFaultItem())
		RemoveFaultItemAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CPortNoType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CPortNoType::GetGroupType()
{
	return eSequence;
}

void CPortNoType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("PortNoScope"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("PortNoScope"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CPortNoType::GetIsInjectMinCount()
{
	return 0;
}


int CPortNoType::GetIsInjectMaxCount()
{
	return 1;
}


int CPortNoType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CPortNoType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CPortNoType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CPortNoType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CPortNoType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CPortNoType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CPortNoType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CPortNoType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CPortNoType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CPortNoType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CPortNoType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CPortNoType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CPortNoType::GetPortNoScopeMinCount()
{
	return 1;
}


int CPortNoType::GetPortNoScopeMaxCount()
{
	return 1;
}


int CPortNoType::GetPortNoScopeCount()
{
	return ChildCountInternal(Element, _T(""), _T("PortNoScope"));
}


bool CPortNoType::HasPortNoScope()
{
	return InternalHasChild(Element, _T(""), _T("PortNoScope"));
}


void CPortNoType::AddPortNoScope(CSchemaLong PortNoScope)
{
	InternalAppend(Element, _T(""), _T("PortNoScope"), PortNoScope);
}


void CPortNoType::InsertPortNoScopeAt(CSchemaLong PortNoScope, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("PortNoScope"), nIndex, PortNoScope);
}


void CPortNoType::ReplacePortNoScopeAt(CSchemaLong PortNoScope, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("PortNoScope"), nIndex, PortNoScope);
}



CSchemaLong CPortNoType::GetPortNoScopeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("PortNoScope"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("PortNoScope"), nIndex));
}

xercesc::DOMNode* CPortNoType::GetStartingPortNoScopeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("PortNoScope"));
}

xercesc::DOMNode* CPortNoType::GetAdvancedPortNoScopeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("PortNoScope"), pCurNode);
}

CSchemaLong CPortNoType::GetPortNoScopeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CPortNoType::GetPortNoScope()
{
	return GetPortNoScopeAt(0);
}


void CPortNoType::RemovePortNoScopeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("PortNoScope"), nIndex);
}


void CPortNoType::RemovePortNoScope()
{
	while (HasPortNoScope())
		RemovePortNoScopeAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CFaultItemType5
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CFaultItemType5::GetGroupType()
{
	return eSequence;
}

void CFaultItemType5::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("PortNo"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("PortNo"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CPortNoType(pDOMNode).AdjustPrefix();
	}
}
int CFaultItemType5::GetPortNoMinCount()
{
	return 1;
}


int CFaultItemType5::GetPortNoMaxCount()
{
	return 1;
}


int CFaultItemType5::GetPortNoCount()
{
	return ChildCountInternal(Element, _T(""), _T("PortNo"));
}


bool CFaultItemType5::HasPortNo()
{
	return InternalHasChild(Element, _T(""), _T("PortNo"));
}


void CFaultItemType5::AddPortNo(CPortNoType& PortNo)
{
	InternalAppendNode(_T(""), _T("PortNo"), PortNo);
}


void CFaultItemType5::InsertPortNoAt(CPortNoType& PortNo, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("PortNo"), nIndex, PortNo);
}


void CFaultItemType5::ReplacePortNoAt(CPortNoType& PortNo, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("PortNo"), nIndex, PortNo);
}



CPortNoType CFaultItemType5::GetPortNoAt(int nIndex)
{
	return CPortNoType(InternalGetAt(Element, _T(""), _T("PortNo"), nIndex));
}

xercesc::DOMNode* CFaultItemType5::GetStartingPortNoCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("PortNo"));
}

xercesc::DOMNode* CFaultItemType5::GetAdvancedPortNoCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("PortNo"), pCurNode);
}

CPortNoType CFaultItemType5::GetPortNoValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CPortNoType(pCurNode);
	}
}



CPortNoType CFaultItemType5::GetPortNo()
{
	return GetPortNoAt(0);
}


void CFaultItemType5::RemovePortNoAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("PortNo"), nIndex);
}


void CFaultItemType5::RemovePortNo()
{
	while (HasPortNo())
		RemovePortNoAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CPortFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CPortFaultType::GetGroupType()
{
	return eSequence;
}

void CPortFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("FaultItem"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("FaultItem"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CFaultItemType5(pDOMNode).AdjustPrefix();
	}
}
int CPortFaultType::GetFaultItemMinCount()
{
	return 1;
}


int CPortFaultType::GetFaultItemMaxCount()
{
	return 1;
}


int CPortFaultType::GetFaultItemCount()
{
	return ChildCountInternal(Element, _T(""), _T("FaultItem"));
}


bool CPortFaultType::HasFaultItem()
{
	return InternalHasChild(Element, _T(""), _T("FaultItem"));
}


void CPortFaultType::AddFaultItem(CFaultItemType5& FaultItem)
{
	InternalAppendNode(_T(""), _T("FaultItem"), FaultItem);
}


void CPortFaultType::InsertFaultItemAt(CFaultItemType5& FaultItem, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}


void CPortFaultType::ReplaceFaultItemAt(CFaultItemType5& FaultItem, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}



CFaultItemType5 CPortFaultType::GetFaultItemAt(int nIndex)
{
	return CFaultItemType5(InternalGetAt(Element, _T(""), _T("FaultItem"), nIndex));
}

xercesc::DOMNode* CPortFaultType::GetStartingFaultItemCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("FaultItem"));
}

xercesc::DOMNode* CPortFaultType::GetAdvancedFaultItemCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("FaultItem"), pCurNode);
}

CFaultItemType5 CPortFaultType::GetFaultItemValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CFaultItemType5(pCurNode);
	}
}



CFaultItemType5 CPortFaultType::GetFaultItem()
{
	return GetFaultItemAt(0);
}


void CPortFaultType::RemoveFaultItemAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("FaultItem"), nIndex);
}


void CPortFaultType::RemoveFaultItem()
{
	while (HasFaultItem())
		RemoveFaultItemAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CRTFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CRTFaultType::GetGroupType()
{
	return eSequence;
}

void CRTFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Attribute, _T(""), _T("IsInject"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Attribute, _T(""), _T("IsInject"), i);
		InternalAdjustPrefix(pDOMNode, false);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Path"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Path"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("ValName"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("ValName"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("ValType"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("ValType"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("Value"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("Value"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CRTFaultType::GetIsInjectMinCount()
{
	return 0;
}


int CRTFaultType::GetIsInjectMaxCount()
{
	return 1;
}


int CRTFaultType::GetIsInjectCount()
{
	return ChildCountInternal(Attribute, _T(""), _T("IsInject"));
}


bool CRTFaultType::HasIsInject()
{
	return InternalHasChild(Attribute, _T(""), _T("IsInject"));
}


void CRTFaultType::AddIsInject(CSchemaBoolean IsInject)
{
	InternalAppend(Attribute, _T(""), _T("IsInject"), IsInject);
}


void CRTFaultType::InsertIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalInsertAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}


void CRTFaultType::ReplaceIsInjectAt(CSchemaBoolean IsInject, int nIndex)
{
	InternalReplaceAt(Attribute, _T(""), _T("IsInject"), nIndex, IsInject);
}



CSchemaBoolean CRTFaultType::GetIsInjectAt(int nIndex)
{
	return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex)).c_str();
	//return InternalGetNodeValue(Attribute, InternalGetAt(Attribute, _T(""), _T("IsInject"), nIndex));
}

xercesc::DOMNode* CRTFaultType::GetStartingIsInjectCursor()
{
	return InternalGetFirstChild(Attribute, _T(""), _T("IsInject"));
}

xercesc::DOMNode* CRTFaultType::GetAdvancedIsInjectCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Attribute, _T(""), _T("IsInject"), pCurNode);
}

CSchemaBoolean CRTFaultType::GetIsInjectValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaBoolean CRTFaultType::GetIsInject()
{
	return GetIsInjectAt(0);
}


void CRTFaultType::RemoveIsInjectAt(int nIndex)
{
	InternalRemoveAt(Attribute, _T(""), _T("IsInject"), nIndex);
}


void CRTFaultType::RemoveIsInject()
{
	while (HasIsInject())
		RemoveIsInjectAt(0);
}

int CRTFaultType::GetPathMinCount()
{
	return 1;
}


int CRTFaultType::GetPathMaxCount()
{
	return 1;
}


int CRTFaultType::GetPathCount()
{
	return ChildCountInternal(Element, _T(""), _T("Path"));
}


bool CRTFaultType::HasPath()
{
	return InternalHasChild(Element, _T(""), _T("Path"));
}


void CRTFaultType::AddPath(CSchemaString Path)
{
	InternalAppend(Element, _T(""), _T("Path"), Path);
}


void CRTFaultType::InsertPathAt(CSchemaString Path, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Path"), nIndex, Path);
}


void CRTFaultType::ReplacePathAt(CSchemaString Path, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Path"), nIndex, Path);
}



CSchemaString CRTFaultType::GetPathAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Path"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Path"), nIndex));
}

xercesc::DOMNode* CRTFaultType::GetStartingPathCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Path"));
}

xercesc::DOMNode* CRTFaultType::GetAdvancedPathCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Path"), pCurNode);
}

CSchemaString CRTFaultType::GetPathValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CRTFaultType::GetPath()
{
	return GetPathAt(0);
}


void CRTFaultType::RemovePathAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Path"), nIndex);
}


void CRTFaultType::RemovePath()
{
	while (HasPath())
		RemovePathAt(0);
}

int CRTFaultType::GetValNameMinCount()
{
	return 1;
}


int CRTFaultType::GetValNameMaxCount()
{
	return 1;
}


int CRTFaultType::GetValNameCount()
{
	return ChildCountInternal(Element, _T(""), _T("ValName"));
}


bool CRTFaultType::HasValName()
{
	return InternalHasChild(Element, _T(""), _T("ValName"));
}


void CRTFaultType::AddValName(CSchemaString ValName)
{
	InternalAppend(Element, _T(""), _T("ValName"), ValName);
}


void CRTFaultType::InsertValNameAt(CSchemaString ValName, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("ValName"), nIndex, ValName);
}


void CRTFaultType::ReplaceValNameAt(CSchemaString ValName, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("ValName"), nIndex, ValName);
}



CSchemaString CRTFaultType::GetValNameAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ValName"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ValName"), nIndex));
}

xercesc::DOMNode* CRTFaultType::GetStartingValNameCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("ValName"));
}

xercesc::DOMNode* CRTFaultType::GetAdvancedValNameCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("ValName"), pCurNode);
}

CSchemaString CRTFaultType::GetValNameValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CRTFaultType::GetValName()
{
	return GetValNameAt(0);
}


void CRTFaultType::RemoveValNameAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("ValName"), nIndex);
}


void CRTFaultType::RemoveValName()
{
	while (HasValName())
		RemoveValNameAt(0);
}

int CRTFaultType::GetValTypeMinCount()
{
	return 1;
}


int CRTFaultType::GetValTypeMaxCount()
{
	return 1;
}


int CRTFaultType::GetValTypeCount()
{
	return ChildCountInternal(Element, _T(""), _T("ValType"));
}


bool CRTFaultType::HasValType()
{
	return InternalHasChild(Element, _T(""), _T("ValType"));
}


void CRTFaultType::AddValType(CSchemaLong ValType)
{
	InternalAppend(Element, _T(""), _T("ValType"), ValType);
}


void CRTFaultType::InsertValTypeAt(CSchemaLong ValType, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("ValType"), nIndex, ValType);
}


void CRTFaultType::ReplaceValTypeAt(CSchemaLong ValType, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("ValType"), nIndex, ValType);
}



CSchemaLong CRTFaultType::GetValTypeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ValType"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("ValType"), nIndex));
}

xercesc::DOMNode* CRTFaultType::GetStartingValTypeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("ValType"));
}

xercesc::DOMNode* CRTFaultType::GetAdvancedValTypeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("ValType"), pCurNode);
}

CSchemaLong CRTFaultType::GetValTypeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CRTFaultType::GetValType()
{
	return GetValTypeAt(0);
}


void CRTFaultType::RemoveValTypeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("ValType"), nIndex);
}


void CRTFaultType::RemoveValType()
{
	while (HasValType())
		RemoveValTypeAt(0);
}

int CRTFaultType::GetValue2MinCount()
{
	return 1;
}


int CRTFaultType::GetValue2MaxCount()
{
	return 1;
}


int CRTFaultType::GetValue2Count()
{
	return ChildCountInternal(Element, _T(""), _T("Value"));
}


bool CRTFaultType::HasValue2()
{
	return InternalHasChild(Element, _T(""), _T("Value"));
}


void CRTFaultType::AddValue2(CSchemaString Value2)
{
	InternalAppend(Element, _T(""), _T("Value"), Value2);
}


void CRTFaultType::InsertValue2At(CSchemaString Value2, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("Value"), nIndex, Value2);
}


void CRTFaultType::ReplaceValue2At(CSchemaString Value2, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("Value"), nIndex, Value2);
}



CSchemaString CRTFaultType::GetValue2At(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Value"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("Value"), nIndex));
}

xercesc::DOMNode* CRTFaultType::GetStartingValue2Cursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("Value"));
}

xercesc::DOMNode* CRTFaultType::GetAdvancedValue2Cursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("Value"), pCurNode);
}

CSchemaString CRTFaultType::GetValue2ValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CRTFaultType::GetValue2()
{
	return GetValue2At(0);
}


void CRTFaultType::RemoveValue2At(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("Value"), nIndex);
}


void CRTFaultType::RemoveValue2()
{
	while (HasValue2())
		RemoveValue2At(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CFaultItemType6
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CFaultItemType6::GetGroupType()
{
	return eSequence;
}

void CFaultItemType6::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("RTFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("RTFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CRTFaultType(pDOMNode).AdjustPrefix();
	}
}
int CFaultItemType6::GetRTFaultMinCount()
{
	return 1;
}


int CFaultItemType6::GetRTFaultMaxCount()
{
	return 1;
}


int CFaultItemType6::GetRTFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("RTFault"));
}


bool CFaultItemType6::HasRTFault()
{
	return InternalHasChild(Element, _T(""), _T("RTFault"));
}


void CFaultItemType6::AddRTFault(CRTFaultType& RTFault)
{
	InternalAppendNode(_T(""), _T("RTFault"), RTFault);
}


void CFaultItemType6::InsertRTFaultAt(CRTFaultType& RTFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("RTFault"), nIndex, RTFault);
}


void CFaultItemType6::ReplaceRTFaultAt(CRTFaultType& RTFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("RTFault"), nIndex, RTFault);
}



CRTFaultType CFaultItemType6::GetRTFaultAt(int nIndex)
{
	return CRTFaultType(InternalGetAt(Element, _T(""), _T("RTFault"), nIndex));
}

xercesc::DOMNode* CFaultItemType6::GetStartingRTFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("RTFault"));
}

xercesc::DOMNode* CFaultItemType6::GetAdvancedRTFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("RTFault"), pCurNode);
}

CRTFaultType CFaultItemType6::GetRTFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CRTFaultType(pCurNode);
	}
}



CRTFaultType CFaultItemType6::GetRTFault()
{
	return GetRTFaultAt(0);
}


void CFaultItemType6::RemoveRTFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("RTFault"), nIndex);
}


void CFaultItemType6::RemoveRTFault()
{
	while (HasRTFault())
		RemoveRTFaultAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CRegisterTableFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CRegisterTableFaultType::GetGroupType()
{
	return eSequence;
}

void CRegisterTableFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("FaultItem"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("FaultItem"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CFaultItemType6(pDOMNode).AdjustPrefix();
	}
}
int CRegisterTableFaultType::GetFaultItemMinCount()
{
	return 1;
}


int CRegisterTableFaultType::GetFaultItemMaxCount()
{
	return 1;
}


int CRegisterTableFaultType::GetFaultItemCount()
{
	return ChildCountInternal(Element, _T(""), _T("FaultItem"));
}


bool CRegisterTableFaultType::HasFaultItem()
{
	return InternalHasChild(Element, _T(""), _T("FaultItem"));
}


void CRegisterTableFaultType::AddFaultItem(CFaultItemType6& FaultItem)
{
	InternalAppendNode(_T(""), _T("FaultItem"), FaultItem);
}


void CRegisterTableFaultType::InsertFaultItemAt(CFaultItemType6& FaultItem, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}


void CRegisterTableFaultType::ReplaceFaultItemAt(CFaultItemType6& FaultItem, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}



CFaultItemType6 CRegisterTableFaultType::GetFaultItemAt(int nIndex)
{
	return CFaultItemType6(InternalGetAt(Element, _T(""), _T("FaultItem"), nIndex));
}

xercesc::DOMNode* CRegisterTableFaultType::GetStartingFaultItemCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("FaultItem"));
}

xercesc::DOMNode* CRegisterTableFaultType::GetAdvancedFaultItemCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("FaultItem"), pCurNode);
}

CFaultItemType6 CRegisterTableFaultType::GetFaultItemValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CFaultItemType6(pCurNode);
	}
}



CFaultItemType6 CRegisterTableFaultType::GetFaultItem()
{
	return GetFaultItemAt(0);
}


void CRegisterTableFaultType::RemoveFaultItemAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("FaultItem"), nIndex);
}


void CRegisterTableFaultType::RemoveFaultItem()
{
	while (HasFaultItem())
		RemoveFaultItemAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CFaultItemType7
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CFaultItemType7::GetGroupType()
{
	return eSequence;
}

void CFaultItemType7::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("VMName"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("VMName"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}

	nCount = ChildCountInternal(Element, _T(""), _T("FaultType"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("FaultType"), i);
		InternalAdjustPrefix(pDOMNode, true);
	}
}
int CFaultItemType7::GetVMNameMinCount()
{
	return 1;
}


int CFaultItemType7::GetVMNameMaxCount()
{
	return 1;
}


int CFaultItemType7::GetVMNameCount()
{
	return ChildCountInternal(Element, _T(""), _T("VMName"));
}


bool CFaultItemType7::HasVMName()
{
	return InternalHasChild(Element, _T(""), _T("VMName"));
}


void CFaultItemType7::AddVMName(CSchemaString VMName)
{
	InternalAppend(Element, _T(""), _T("VMName"), VMName);
}


void CFaultItemType7::InsertVMNameAt(CSchemaString VMName, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("VMName"), nIndex, VMName);
}


void CFaultItemType7::ReplaceVMNameAt(CSchemaString VMName, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("VMName"), nIndex, VMName);
}



CSchemaString CFaultItemType7::GetVMNameAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("VMName"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("VMName"), nIndex));
}

xercesc::DOMNode* CFaultItemType7::GetStartingVMNameCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("VMName"));
}

xercesc::DOMNode* CFaultItemType7::GetAdvancedVMNameCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("VMName"), pCurNode);
}

CSchemaString CFaultItemType7::GetVMNameValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaString CFaultItemType7::GetVMName()
{
	return GetVMNameAt(0);
}


void CFaultItemType7::RemoveVMNameAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("VMName"), nIndex);
}


void CFaultItemType7::RemoveVMName()
{
	while (HasVMName())
		RemoveVMNameAt(0);
}

int CFaultItemType7::GetFaultTypeMinCount()
{
	return 1;
}


int CFaultItemType7::GetFaultTypeMaxCount()
{
	return 1;
}


int CFaultItemType7::GetFaultTypeCount()
{
	return ChildCountInternal(Element, _T(""), _T("FaultType"));
}


bool CFaultItemType7::HasFaultType()
{
	return InternalHasChild(Element, _T(""), _T("FaultType"));
}


void CFaultItemType7::AddFaultType(CSchemaLong FaultType)
{
	InternalAppend(Element, _T(""), _T("FaultType"), FaultType);
}


void CFaultItemType7::InsertFaultTypeAt(CSchemaLong FaultType, int nIndex)
{
	InternalInsertAt(Element, _T(""), _T("FaultType"), nIndex, FaultType);
}


void CFaultItemType7::ReplaceFaultTypeAt(CSchemaLong FaultType, int nIndex)
{
	InternalReplaceAt(Element, _T(""), _T("FaultType"), nIndex, FaultType);
}



CSchemaLong CFaultItemType7::GetFaultTypeAt(int nIndex)
{
	return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("FaultType"), nIndex)).c_str();
	//return InternalGetNodeValue(Element, InternalGetAt(Element, _T(""), _T("FaultType"), nIndex));
}

xercesc::DOMNode* CFaultItemType7::GetStartingFaultTypeCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("FaultType"));
}

xercesc::DOMNode* CFaultItemType7::GetAdvancedFaultTypeCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("FaultType"), pCurNode);
}

CSchemaLong CFaultItemType7::GetFaultTypeValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
	}
}



CSchemaLong CFaultItemType7::GetFaultType()
{
	return GetFaultTypeAt(0);
}


void CFaultItemType7::RemoveFaultTypeAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("FaultType"), nIndex);
}


void CFaultItemType7::RemoveFaultType()
{
	while (HasFaultType())
		RemoveFaultTypeAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CVirtualMachineFaultType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CVirtualMachineFaultType::GetGroupType()
{
	return eSequence;
}

void CVirtualMachineFaultType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("FaultItem"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("FaultItem"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CFaultItemType7(pDOMNode).AdjustPrefix();
	}
}
int CVirtualMachineFaultType::GetFaultItemMinCount()
{
	return 1;
}


int CVirtualMachineFaultType::GetFaultItemMaxCount()
{
	return 1;
}


int CVirtualMachineFaultType::GetFaultItemCount()
{
	return ChildCountInternal(Element, _T(""), _T("FaultItem"));
}


bool CVirtualMachineFaultType::HasFaultItem()
{
	return InternalHasChild(Element, _T(""), _T("FaultItem"));
}


void CVirtualMachineFaultType::AddFaultItem(CFaultItemType7& FaultItem)
{
	InternalAppendNode(_T(""), _T("FaultItem"), FaultItem);
}


void CVirtualMachineFaultType::InsertFaultItemAt(CFaultItemType7& FaultItem, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}


void CVirtualMachineFaultType::ReplaceFaultItemAt(CFaultItemType7& FaultItem, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("FaultItem"), nIndex, FaultItem);
}



CFaultItemType7 CVirtualMachineFaultType::GetFaultItemAt(int nIndex)
{
	return CFaultItemType7(InternalGetAt(Element, _T(""), _T("FaultItem"), nIndex));
}

xercesc::DOMNode* CVirtualMachineFaultType::GetStartingFaultItemCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("FaultItem"));
}

xercesc::DOMNode* CVirtualMachineFaultType::GetAdvancedFaultItemCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("FaultItem"), pCurNode);
}

CFaultItemType7 CVirtualMachineFaultType::GetFaultItemValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CFaultItemType7(pCurNode);
	}
}



CFaultItemType7 CVirtualMachineFaultType::GetFaultItem()
{
	return GetFaultItemAt(0);
}


void CVirtualMachineFaultType::RemoveFaultItemAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("FaultItem"), nIndex);
}


void CVirtualMachineFaultType::RemoveFaultItem()
{
	while (HasFaultItem())
		RemoveFaultItemAt(0);
}

////////////////////////////////////////////////////////////////////////
//
// class CFaultInjectXMLType
//
////////////////////////////////////////////////////////////////////////


CNode::EGroupType CFaultInjectXMLType::GetGroupType()
{
	return eSequence;
}

void CFaultInjectXMLType::AdjustPrefix()
{
	int i, nCount;

	nCount = ChildCountInternal(Element, _T(""), _T("NetWokFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("NetWokFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CNetWokFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("HostFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("HostFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CHostFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("DBFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("DBFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CDBFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("BasicServiceFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("BasicServiceFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CBasicServiceFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("VirtualMachineFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("VirtualMachineFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CVirtualMachineFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("RegisterTableFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("RegisterTableFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CRegisterTableFaultType(pDOMNode).AdjustPrefix();
	}

	nCount = ChildCountInternal(Element, _T(""), _T("PortFault"));
	for (i = 0; i < nCount; i++)
	{
		xercesc::DOMNode* pDOMNode = InternalGetAt(Element, _T(""), _T("PortFault"), i);
		InternalAdjustPrefix(pDOMNode, true);
		CPortFaultType(pDOMNode).AdjustPrefix();
	}
}
int CFaultInjectXMLType::GetNetWokFaultMinCount()
{
	return 1;
}


int CFaultInjectXMLType::GetNetWokFaultMaxCount()
{
	return 1;
}


int CFaultInjectXMLType::GetNetWokFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("NetWokFault"));
}


bool CFaultInjectXMLType::HasNetWokFault()
{
	return InternalHasChild(Element, _T(""), _T("NetWokFault"));
}


void CFaultInjectXMLType::AddNetWokFault(CNetWokFaultType& NetWokFault)
{
	InternalAppendNode(_T(""), _T("NetWokFault"), NetWokFault);
}


void CFaultInjectXMLType::InsertNetWokFaultAt(CNetWokFaultType& NetWokFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("NetWokFault"), nIndex, NetWokFault);
}


void CFaultInjectXMLType::ReplaceNetWokFaultAt(CNetWokFaultType& NetWokFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("NetWokFault"), nIndex, NetWokFault);
}



CNetWokFaultType CFaultInjectXMLType::GetNetWokFaultAt(int nIndex)
{
	return CNetWokFaultType(InternalGetAt(Element, _T(""), _T("NetWokFault"), nIndex));
}

xercesc::DOMNode* CFaultInjectXMLType::GetStartingNetWokFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("NetWokFault"));
}

xercesc::DOMNode* CFaultInjectXMLType::GetAdvancedNetWokFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("NetWokFault"), pCurNode);
}

CNetWokFaultType CFaultInjectXMLType::GetNetWokFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CNetWokFaultType(pCurNode);
	}
}



CNetWokFaultType CFaultInjectXMLType::GetNetWokFault()
{
	return GetNetWokFaultAt(0);
}


void CFaultInjectXMLType::RemoveNetWokFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("NetWokFault"), nIndex);
}


void CFaultInjectXMLType::RemoveNetWokFault()
{
	while (HasNetWokFault())
		RemoveNetWokFaultAt(0);
}

int CFaultInjectXMLType::GetHostFaultMinCount()
{
	return 1;
}


int CFaultInjectXMLType::GetHostFaultMaxCount()
{
	return 1;
}


int CFaultInjectXMLType::GetHostFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("HostFault"));
}


bool CFaultInjectXMLType::HasHostFault()
{
	return InternalHasChild(Element, _T(""), _T("HostFault"));
}


void CFaultInjectXMLType::AddHostFault(CHostFaultType& HostFault)
{
	InternalAppendNode(_T(""), _T("HostFault"), HostFault);
}


void CFaultInjectXMLType::InsertHostFaultAt(CHostFaultType& HostFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("HostFault"), nIndex, HostFault);
}


void CFaultInjectXMLType::ReplaceHostFaultAt(CHostFaultType& HostFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("HostFault"), nIndex, HostFault);
}



CHostFaultType CFaultInjectXMLType::GetHostFaultAt(int nIndex)
{
	return CHostFaultType(InternalGetAt(Element, _T(""), _T("HostFault"), nIndex));
}

xercesc::DOMNode* CFaultInjectXMLType::GetStartingHostFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("HostFault"));
}

xercesc::DOMNode* CFaultInjectXMLType::GetAdvancedHostFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("HostFault"), pCurNode);
}

CHostFaultType CFaultInjectXMLType::GetHostFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CHostFaultType(pCurNode);
	}
}



CHostFaultType CFaultInjectXMLType::GetHostFault()
{
	return GetHostFaultAt(0);
}


void CFaultInjectXMLType::RemoveHostFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("HostFault"), nIndex);
}


void CFaultInjectXMLType::RemoveHostFault()
{
	while (HasHostFault())
		RemoveHostFaultAt(0);
}

int CFaultInjectXMLType::GetDBFaultMinCount()
{
	return 1;
}


int CFaultInjectXMLType::GetDBFaultMaxCount()
{
	return 1;
}


int CFaultInjectXMLType::GetDBFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("DBFault"));
}


bool CFaultInjectXMLType::HasDBFault()
{
	return InternalHasChild(Element, _T(""), _T("DBFault"));
}


void CFaultInjectXMLType::AddDBFault(CDBFaultType& DBFault)
{
	InternalAppendNode(_T(""), _T("DBFault"), DBFault);
}


void CFaultInjectXMLType::InsertDBFaultAt(CDBFaultType& DBFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("DBFault"), nIndex, DBFault);
}


void CFaultInjectXMLType::ReplaceDBFaultAt(CDBFaultType& DBFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("DBFault"), nIndex, DBFault);
}



CDBFaultType CFaultInjectXMLType::GetDBFaultAt(int nIndex)
{
	return CDBFaultType(InternalGetAt(Element, _T(""), _T("DBFault"), nIndex));
}

xercesc::DOMNode* CFaultInjectXMLType::GetStartingDBFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("DBFault"));
}

xercesc::DOMNode* CFaultInjectXMLType::GetAdvancedDBFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("DBFault"), pCurNode);
}

CDBFaultType CFaultInjectXMLType::GetDBFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CDBFaultType(pCurNode);
	}
}



CDBFaultType CFaultInjectXMLType::GetDBFault()
{
	return GetDBFaultAt(0);
}


void CFaultInjectXMLType::RemoveDBFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("DBFault"), nIndex);
}


void CFaultInjectXMLType::RemoveDBFault()
{
	while (HasDBFault())
		RemoveDBFaultAt(0);
}

int CFaultInjectXMLType::GetBasicServiceFaultMinCount()
{
	return 1;
}


int CFaultInjectXMLType::GetBasicServiceFaultMaxCount()
{
	return 1;
}


int CFaultInjectXMLType::GetBasicServiceFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("BasicServiceFault"));
}


bool CFaultInjectXMLType::HasBasicServiceFault()
{
	return InternalHasChild(Element, _T(""), _T("BasicServiceFault"));
}


void CFaultInjectXMLType::AddBasicServiceFault(CBasicServiceFaultType& BasicServiceFault)
{
	InternalAppendNode(_T(""), _T("BasicServiceFault"), BasicServiceFault);
}


void CFaultInjectXMLType::InsertBasicServiceFaultAt(CBasicServiceFaultType& BasicServiceFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("BasicServiceFault"), nIndex, BasicServiceFault);
}


void CFaultInjectXMLType::ReplaceBasicServiceFaultAt(CBasicServiceFaultType& BasicServiceFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("BasicServiceFault"), nIndex, BasicServiceFault);
}



CBasicServiceFaultType CFaultInjectXMLType::GetBasicServiceFaultAt(int nIndex)
{
	return CBasicServiceFaultType(InternalGetAt(Element, _T(""), _T("BasicServiceFault"), nIndex));
}

xercesc::DOMNode* CFaultInjectXMLType::GetStartingBasicServiceFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("BasicServiceFault"));
}

xercesc::DOMNode* CFaultInjectXMLType::GetAdvancedBasicServiceFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("BasicServiceFault"), pCurNode);
}

CBasicServiceFaultType CFaultInjectXMLType::GetBasicServiceFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CBasicServiceFaultType(pCurNode);
	}
}



CBasicServiceFaultType CFaultInjectXMLType::GetBasicServiceFault()
{
	return GetBasicServiceFaultAt(0);
}


void CFaultInjectXMLType::RemoveBasicServiceFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("BasicServiceFault"), nIndex);
}


void CFaultInjectXMLType::RemoveBasicServiceFault()
{
	while (HasBasicServiceFault())
		RemoveBasicServiceFaultAt(0);
}

int CFaultInjectXMLType::GetVirtualMachineFaultMinCount()
{
	return 1;
}


int CFaultInjectXMLType::GetVirtualMachineFaultMaxCount()
{
	return 1;
}


int CFaultInjectXMLType::GetVirtualMachineFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("VirtualMachineFault"));
}


bool CFaultInjectXMLType::HasVirtualMachineFault()
{
	return InternalHasChild(Element, _T(""), _T("VirtualMachineFault"));
}


void CFaultInjectXMLType::AddVirtualMachineFault(CVirtualMachineFaultType& VirtualMachineFault)
{
	InternalAppendNode(_T(""), _T("VirtualMachineFault"), VirtualMachineFault);
}


void CFaultInjectXMLType::InsertVirtualMachineFaultAt(CVirtualMachineFaultType& VirtualMachineFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("VirtualMachineFault"), nIndex, VirtualMachineFault);
}


void CFaultInjectXMLType::ReplaceVirtualMachineFaultAt(CVirtualMachineFaultType& VirtualMachineFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("VirtualMachineFault"), nIndex, VirtualMachineFault);
}



CVirtualMachineFaultType CFaultInjectXMLType::GetVirtualMachineFaultAt(int nIndex)
{
	return CVirtualMachineFaultType(InternalGetAt(Element, _T(""), _T("VirtualMachineFault"), nIndex));
}

xercesc::DOMNode* CFaultInjectXMLType::GetStartingVirtualMachineFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("VirtualMachineFault"));
}

xercesc::DOMNode* CFaultInjectXMLType::GetAdvancedVirtualMachineFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("VirtualMachineFault"), pCurNode);
}

CVirtualMachineFaultType CFaultInjectXMLType::GetVirtualMachineFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CVirtualMachineFaultType(pCurNode);
	}
}



CVirtualMachineFaultType CFaultInjectXMLType::GetVirtualMachineFault()
{
	return GetVirtualMachineFaultAt(0);
}


void CFaultInjectXMLType::RemoveVirtualMachineFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("VirtualMachineFault"), nIndex);
}


void CFaultInjectXMLType::RemoveVirtualMachineFault()
{
	while (HasVirtualMachineFault())
		RemoveVirtualMachineFaultAt(0);
}

int CFaultInjectXMLType::GetRegisterTableFaultMinCount()
{
	return 1;
}


int CFaultInjectXMLType::GetRegisterTableFaultMaxCount()
{
	return 1;
}


int CFaultInjectXMLType::GetRegisterTableFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("RegisterTableFault"));
}


bool CFaultInjectXMLType::HasRegisterTableFault()
{
	return InternalHasChild(Element, _T(""), _T("RegisterTableFault"));
}


void CFaultInjectXMLType::AddRegisterTableFault(CRegisterTableFaultType& RegisterTableFault)
{
	InternalAppendNode(_T(""), _T("RegisterTableFault"), RegisterTableFault);
}


void CFaultInjectXMLType::InsertRegisterTableFaultAt(CRegisterTableFaultType& RegisterTableFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("RegisterTableFault"), nIndex, RegisterTableFault);
}


void CFaultInjectXMLType::ReplaceRegisterTableFaultAt(CRegisterTableFaultType& RegisterTableFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("RegisterTableFault"), nIndex, RegisterTableFault);
}



CRegisterTableFaultType CFaultInjectXMLType::GetRegisterTableFaultAt(int nIndex)
{
	return CRegisterTableFaultType(InternalGetAt(Element, _T(""), _T("RegisterTableFault"), nIndex));
}

xercesc::DOMNode* CFaultInjectXMLType::GetStartingRegisterTableFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("RegisterTableFault"));
}

xercesc::DOMNode* CFaultInjectXMLType::GetAdvancedRegisterTableFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("RegisterTableFault"), pCurNode);
}

CRegisterTableFaultType CFaultInjectXMLType::GetRegisterTableFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CRegisterTableFaultType(pCurNode);
	}
}



CRegisterTableFaultType CFaultInjectXMLType::GetRegisterTableFault()
{
	return GetRegisterTableFaultAt(0);
}


void CFaultInjectXMLType::RemoveRegisterTableFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("RegisterTableFault"), nIndex);
}


void CFaultInjectXMLType::RemoveRegisterTableFault()
{
	while (HasRegisterTableFault())
		RemoveRegisterTableFaultAt(0);
}

int CFaultInjectXMLType::GetPortFaultMinCount()
{
	return 1;
}


int CFaultInjectXMLType::GetPortFaultMaxCount()
{
	return 1;
}


int CFaultInjectXMLType::GetPortFaultCount()
{
	return ChildCountInternal(Element, _T(""), _T("PortFault"));
}


bool CFaultInjectXMLType::HasPortFault()
{
	return InternalHasChild(Element, _T(""), _T("PortFault"));
}


void CFaultInjectXMLType::AddPortFault(CPortFaultType& PortFault)
{
	InternalAppendNode(_T(""), _T("PortFault"), PortFault);
}


void CFaultInjectXMLType::InsertPortFaultAt(CPortFaultType& PortFault, int nIndex)
{
	InternalInsertNodeAt(_T(""), _T("PortFault"), nIndex, PortFault);
}


void CFaultInjectXMLType::ReplacePortFaultAt(CPortFaultType& PortFault, int nIndex)
{
	InternalReplaceNodeAt(_T(""), _T("PortFault"), nIndex, PortFault);
}



CPortFaultType CFaultInjectXMLType::GetPortFaultAt(int nIndex)
{
	return CPortFaultType(InternalGetAt(Element, _T(""), _T("PortFault"), nIndex));
}

xercesc::DOMNode* CFaultInjectXMLType::GetStartingPortFaultCursor()
{
	return InternalGetFirstChild(Element, _T(""), _T("PortFault"));
}

xercesc::DOMNode* CFaultInjectXMLType::GetAdvancedPortFaultCursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild(Element, _T(""), _T("PortFault"), pCurNode);
}

CPortFaultType CFaultInjectXMLType::GetPortFaultValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
		return CPortFaultType(pCurNode);
	}
}



CPortFaultType CFaultInjectXMLType::GetPortFault()
{
	return GetPortFaultAt(0);
}


void CFaultInjectXMLType::RemovePortFaultAt(int nIndex)
{
	InternalRemoveAt(Element, _T(""), _T("PortFault"), nIndex);
}


void CFaultInjectXMLType::RemovePortFault()
{
	while (HasPortFault())
		RemovePortFaultAt(0);
}


}
